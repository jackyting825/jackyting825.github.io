<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>k3s集群搭建及导入到rancher2.7.9中进行管理维护</title>
      <link href="/2024/01/29/k3s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%AF%BC%E5%85%A5%E5%88%B0rancher2-7-9%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4/"/>
      <url>/2024/01/29/k3s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%AF%BC%E5%85%A5%E5%88%B0rancher2-7-9%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  之前在rocky linux上学习使用搭建了k8s集群，本以为能用的很丝滑，奈何k8s集群占用的资源太大了，几个虚拟机一开再跑一套k8s集群，本本16G的内存都吃不消了，  了解到k3s集群占用的资源少，所以又搭建了一个k3s集群，学习一下k3s集群的使用，本文就是k3s集群搭建及导入到rancher2.7.9中进行维护管理的记录。</code></pre><p>k3s和k8s的联系及区别，官网具体介绍如下：</p><blockquote><p><a href="https://docs.rancher.cn/docs/k3s/_index" target="_blank" rel="noopener">https://docs.rancher.cn/docs/k3s/_index</a></p></blockquote><pre><code>K3s 是一个轻量级的 Kubernetes 发行版，它针对边缘计算、物联网等场景进行了高度优化。K3s 有以下增强功能：打包为单个二进制文件。使用基于 sqlite3 的轻量级存储后端作为默认存储机制。同时支持使用 etcd3、MySQL 和 PostgreSQL 作为存储机制。封装在简单的启动程序中，通过该启动程序处理很多复杂的 TLS 和选项。默认情况下是安全的，对轻量级环境有合理的默认值。添加了简单但功能强大的batteries-included功能，例如：本地存储提供程序，服务负载均衡器，Helm controller 和 Traefik Ingress controller。所有 Kubernetes control-plane 组件的操作都封装在单个二进制文件和进程中，使 K3s 具有自动化和管理包括证书分发在内的复杂集群操作的能力。最大程度减轻了外部依赖性，K3s 仅需要 kernel 和 cgroup 挂载。 K3s 软件包需要的依赖项包括：1.containerd2.Flannel3.CoreDNS4.CNI5.主机实用程序（iptables、socat 等）6.Ingress controller（Traefik）7.嵌入式服务负载均衡器（service load balancer）8.嵌入式网络策略控制器（network policy controller）适用场景#K3s 适用于以下场景：1.边缘计算-Edge2.物联网-IoT3.CI4.Development5.ARM6.嵌入 K8s由于运行 K3s 所需的资源相对较少，所以 K3s 也适用于开发和测试场景。在这些场景中，如果开发或测试人员需要对某些功能进行验证，或对某些问题进行重现，那么使用 K3s 不仅能够缩短启动集群的时间，还能够减少集群需要消耗的资源。与此同时，Rancher 中国团队推出了一款针对 K3s 的效率提升工具：AutoK3s。只需要输入一行命令，即可快速创建 K3s 集群并添加指定数量的 master 节点和 worker 节点。</code></pre><p>安装k3s集群要求:</p><blockquote><p><a href="https://docs.rancher.cn/docs/k3s/installation/installation-requirements/_index" target="_blank" rel="noopener">https://docs.rancher.cn/docs/k3s/installation/installation-requirements/_index</a></p></blockquote><pre><code>1.先决条件节点不能有相同的主机名。如果您的所有节点都有相同的主机名，请使用--with-node-id选项为每个节点添加一个随机后缀，或者为您添加到集群的每个节点设计一个独特的名称，用--node-name或$K3S_NODE_NAME传递。2.硬件CPU： 最低1核  内存： 最低 512MB（建议至少为 1GB）3.网络 K3s server 需要 6443 端口才能被所有节点访问</code></pre><blockquote><p>系统环境 Rocky Linux9.3，采用1主2从的架构</p></blockquote><p>官网安装手册文档如下： <a href="https://docs.rancher.cn/docs/k3s/quick-start/_index" target="_blank" rel="noopener">https://docs.rancher.cn/docs/k3s/quick-start/_index</a></p><h3 id="安装k3s集群"><a href="#安装k3s集群" class="headerlink" title="安装k3s集群"></a>安装k3s集群</h3><h4 id="安装master节点"><a href="#安装master节点" class="headerlink" title="安装master节点"></a>安装master节点</h4><pre><code>curl -sfL https://get.k3s.io | sh -也可以使用下面的国内镜像，加快下载速度：curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -检查结果k3s check-config # 检查安装是否成功得到nodetokencat /var/lib/rancher/k3s/server/node-token</code></pre><blockquote><p>注： 如果系统是Rocky Linux9.3的话，k3s check-config的结果应该是成功。如果系统是centos7的话，k3s check-config的结果应该是失败，提示如下： </p></blockquote><pre><code>(RHEL7/CentOS7: User namespaces disabled; add &apos;user_namespace.enable=1&apos; to boot command line)</code></pre><p>使用下面命令开启</p><pre><code>grubby --args=&quot;user_namespace.enable=1&quot; --update-kernel=&quot;$(grubby --default-kernel)&quot;重新启动reboot</code></pre><h4 id="加入worker节点"><a href="#加入worker节点" class="headerlink" title="加入worker节点"></a>加入worker节点</h4><pre><code>curl -sfL https://get.k3s.io | K3S_URL=https://myserver:6443 K3S_TOKEN=mynodetoken sh -也可以使用下面的国内镜像，加快下载速度：curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn K3S_URL=https://myserver:6443 K3S_TOKEN=mynodetoken sh -</code></pre><blockquote><p>设置K3S_URL参数会使 K3s 以 worker 模式运行。K3s agent 将在所提供的 URL 上向监听的 K3s 服务器注册。K3S_TOKEN使用的值存储在你的服务器节点上的/var/lib/rancher/k3s/server/node-token路径下。</p></blockquote><p>官网上提供的流程就是这样的，理论上是可以的，但是实际操作发现，master节点无任何问题，k3s服务也确实能启动。但是加入worker节点时，发现worker节点的k3s-agent服务启动一直卡住，过了很长一段时间，最终失败，错误信息如下：</p><pre><code># 查看worker节点的k3s-agent服务状态systemctl status k3s-agent.serviceRemotedialer proxy error&quot; error=&quot;dial tcp 10.0.2.15:6443: c...n refused&quot;</code></pre><p>what? 哪儿来的10.0.2.15这个ip了。通过ip addr 查看发现，我虚拟机环境下每台机器的enp0s3网卡(NAT网络地址转换)的ip地址都是10.0.2.15。网卡使用的是NAT网络地址转换模式，为了访问外网必须的。而且手动将enp0s3网卡的ip设置成静态的话，则会导致虚拟机内部的系统无法访问外网。于是查询了很多文档，最终得知<b>k3s集群部署默认是使用eth0网卡</b>,即我这儿的enp0s3网卡</p><p>  我虚拟机目前2张网卡，第一张是enp0s3网卡(NAT网络地址转换；访问外网必须)；第二张是enp0s8网卡(hostonly模式，静态ip地址;集群内部互通使用)。</p><p> <img src="/images/k3s_ip.jpeg" alt></p><p> 此时，可以使用搜索引擎搜索”k3s 多网卡”相关关键字，或者翻看官网文档的安装选项菜单下的内容，可以通过配置选项作为命令标志和环境变量传递进去来改变相关的网络配置。</p><p>  <img src="/images/k3s_server1.jpeg" alt></p><p>  <img src="/images/k3s_server2.jpeg" alt></p><p>至此重新安装master节点</p><pre><code>curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | \INSTALL_K3S_MIRROR=cn \INSTALL_K3S_EXEC=&quot;--advertise-address=192.168.56.121 --node-ip=192.168.56.121&quot; \K3S_KUBECONFIG_OUTPUT=/root/.kube/config \sh -</code></pre><p> –advertise-address apiserver 用来向集群成员发布的 IP 地址;192.168.56.121 是我的master节点地址</p><p> –node-ip 为节点发布的 IP 地址 (server 内嵌了 agent 进程)</p><p> 同样加入worker节点也需要指定节点发布的ip</p><p>   <img src="/images/k3s_worker1.jpeg" alt></p><pre><code>curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn \K3S_URL=https://192.168.56.121:6443 \K3S_TOKEN=nodetoken \K3S_KUBECONFIG_OUTPUT=/root/.kube/config \INSTALL_K3S_EXEC=&quot;--node-ip=192.168.56.122&quot; \sh -</code></pre><p>nodetoken 换成cat /var/lib/rancher/k3s/server/node-token 得到的token值</p><p>192.168.56.122 是我第一台worker节点的ip地址</p><p>等待差不多1分钟，就安装完成，并且k3s-agent服务启动成功。</p><p>同样将上述命令中的节点ip稍作修改，在第二台worker节点上执行即可。</p><p>此时在k3s server节点上，可以使用kubectl命令查看集群状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes 或者 k3s kubectl get nodes</span><br></pre></td></tr></table></figure><p>结果如下：<br>   <img src="/images/k3s_cluster.jpeg" alt></p><blockquote><p>默认集群创建成功后，worker节点的roles值为none。我图中的worker节点 roles值是我通过kubectl命令手动修改的。在k3s server节点上，可以使用kubectl命令修改worker节点的roles值为worker </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label no node3(节点机器的hostname) kubernetes.io/role=worker(设置的值)</span><br></pre></td></tr></table></figure><h3 id="rancher2-7-9导入k3s集群"><a href="#rancher2-7-9导入k3s集群" class="headerlink" title="rancher2.7.9导入k3s集群"></a>rancher2.7.9导入k3s集群</h3><blockquote><p>rancher 导入k3s的集群跟之前导入k8s的集群流程一模一样。相关流程在上一篇笔记中已经写过，这里不再重复。这儿展示下导入成功后的效果。</p></blockquote><p><img src="/images/rancher_k3s_import_succ.jpeg" alt></p><p><img src="/images/rancher_k3s_import_succ1.jpeg" alt></p><p>部署应用相关的流程跟k8s集群的操作一模一样。至此，本本在16G内存的上也能愉快的学习使用k3s(k8s)集群了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> Rocky Linux </tag>
            
            <tag> virtualbox </tag>
            
            <tag> centos7.9 </tag>
            
            <tag> k3s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RockyLinux安装rancher2-7-9导入k8s集群</title>
      <link href="/2024/01/20/RockyLinux%E5%AE%89%E8%A3%85rancher2-7-9%E5%AF%BC%E5%85%A5k8s%E9%9B%86%E7%BE%A4/"/>
      <url>/2024/01/20/RockyLinux%E5%AE%89%E8%A3%85rancher2-7-9%E5%AF%BC%E5%85%A5k8s%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>rancher2.7.9官网有好几种安装方式，目前不推荐使用docker安装的方式了，但是作为个人学习使用，使用docker方式安装是最方便快捷的了。</p></blockquote><p>当前采用的系统是Rocky Linux 9.3,已装好docker。</p><p>打开rancher官网：<a href="https://www.rancher.cn/quick-start" target="_blank" rel="noopener">https://www.rancher.cn/quick-start</a></p><p>  <img src="/images/rancher_required.jpeg" alt></p><p>拷贝图中的命令执行即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --privileged -d --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher:stable</span><br></pre></td></tr></table></figure><blockquote><p>截止目前为止(2024-01-20)，如果把镜像版本更改为rancher:2.7.9，会提示找不到对应镜像的，所以直接拷贝官网的stable版本</p></blockquote><p>  <img src="/images/rancher_not_found.jpeg" alt></p><p>正常情况下，是能够直接安装并启动成功的（之前在debian12系统上这样就能直接安装成功）；但是在Rocky Linux 9.3系统上，拉取镜像后启动容器会失败，docker logs 容器id查看相关错误信息如下：</p><p>  <img src="/images/rancher_ps.jpeg" alt></p><p>  <img src="/images/rancher_error.jpeg" alt></p><p>从rancher论坛上查询相关错误问题信息，得知是</p><blockquote><p>由于较新版本的docker使用了cgroupv2引起的，使用cgroupv2本身并没有错，一些今年发布的Linux发行版也都开始切换到cgroupv2，这也是大势所趋。不过，Rancher server的docker镜像，还要考虑历史兼容的问题，所以server内置的k3s还不兼容cgroupv2的方式。</p></blockquote><blockquote><p>Cgroup（Control Group）是Linux内核提供的一个重要的资源管理工具，用于在容器化环境中对进程进行资源限制和控制。它可以将一组进程组织在一个层次结构中，并通过资源控制机制对每个层次的进程进行限制和分配资源。Cgroup能够控制CPU、内存、磁盘I/O等资源的使用情况，确保容器中的进程不会无限制地占用系统资源。Docker作为一个流行的容器化平台，也使用了cgroup来进行资源管理。</p></blockquote><p>查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount | grep cgroup</span><br></pre></td></tr></table></figure><p>得到如下信息：cgroup2 on /sys/fs/cgroup type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate,memory_recursiveprot)</p><p>rocky linux9.3 默认确实是cgroup v2版本</p><p>论坛相关人员提出解决方式可以将docker的cgroup版本切回到v1，但是我在rocky linux上试了无效。具体流程如下：</p><blockquote><p>启动cgroup2的方式，如果系统内核版本 &gt; 4.5 ，那么就可以通过内核参数的形式启用 cgroups v2 ，不过需要注意的是，部分未默认开启的发行版强制开启后，仓库内的软件可能存在不兼容的问题。对于使用 systemd 引导的系统，可以在引导文件 /etc/default/grub 中添加如下一行，启用 v2 版本。GRUB_CMDLINE_LINUX_DEFAULT=”systemd.unified_cgroup_hierarchy=yes”</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r <span class="comment"># 查看系统内核版本</span></span><br><span class="line">5.14.0-362.8.1.el9_3.x86_64</span><br></pre></td></tr></table></figure><p>rocky linux9.3内核版本为5.14.0-362.8.1.el9_3.x86_64</p><p>打开引导文件/etc/default/grub，在GRUB_CMDLINE_LINUX_DEFAULT项追加：systemd.unified_cgroup_hierarchy=0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/grub</span><br><span class="line">退出保存再执行</span><br><span class="line">/usr/sbin/grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><p>reboot重启系统,执行mount | grep cgroup 再次查看，cgroup版本</p><p>  <img src="/images/cgroupv1.jpeg" alt></p><p>再次执行docker run –privileged -d –restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher:stable，结果还是会报上面的“Waiting for server to become available: Get “<a href="https://127.0.0.1:6443/version?timeout=15m0s&quot;" target="_blank" rel="noopener">https://127.0.0.1:6443/version?timeout=15m0s&quot;</a>: dial tcp 127.0.0.1:6443: connect: connection refused”错误。</p><p>最终在git hub上找到了相关问题，并提出了一个方法，试了下确实可以解决，链接如下：</p><blockquote><p><a href="https://github.com/rancher/rancher/issues/36238" target="_blank" rel="noopener">https://github.com/rancher/rancher/issues/36238</a></p></blockquote><p>先停止掉启动失败的容器</p><p>  <img src="/images/rancher_error_stop.jpeg" alt></p><p>  <img src="/images/rancher_error_solution.jpeg" alt></p><p>  不需要安装iptables,只需要将缺失的iptables模块加载到内核中：</p><pre><code class="bash">  sudo cat&lt;&lt;EOF &gt;/etc/modules-load.d/modules.confiptable_natiptable_filterEOF</code></pre><p>然后reboot重启系统，再次执行docker run –privileged -d –restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher:stable，等候几十秒后，成功启动rancher容器。</p><p>打开浏览器，访问地址<a href="https://192.168.56.110" target="_blank" rel="noopener">https://192.168.56.110</a>  (192.168.56.110我虚拟机的ip地址)，看到如下页面：</p><p>  <img src="/images/rancher_succ.jpeg" alt></p><p>打开终端，输入图中圈着的命令，将container-id替换为实际的容器id</p><p>  <img src="/images/rancher_first_passwd.jpeg" alt></p><p>将得到的密码复制到rancher的登陆密码框中登陆即可，然后重新设置自己的新密码。至此，rancher2.7.9安装成功。下一步导入之前创建好的k8s集群即可。</p><p>下面是具体的导入步骤：</p><p>  rancher集群管理界面进入导入</p><p>  <img src="/images/k8s_import1.jpeg" alt></p><p>  选择通用</p><p>  <img src="/images/k8s_import2.jpeg" alt></p><p>  输入集群相关名称信息，点击创建</p><p>  <img src="/images/k8s_import3.jpeg" alt>  </p><p>  在k8s集群master节点输入如下命令，将k8s集群导入到rancher中</p><p>  <img src="/images/k8s_import4.jpeg" alt>    </p><p>  等待k8s拉取相关镜像，通过kubectl命令查看pod状态，与rancher相关的pod都是running状态的时候就代表导入成功了。</p><p>  <img src="/images/k8s_import5.jpeg" alt>  </p><p>  回到rancher界面，查看集群此时的状态，应该就是active,至此导入k8s集群到rancher成功。</p><p>  <img src="/images/k8s_import6.jpeg" alt>    </p><p>  接下来就可以在rancher中管理k8s集群了。</p><p>  <img src="/images/k8s_import7.jpeg" alt>      </p><p>进入到集群内部，左侧的工作负载下面的菜单分别按照名称对应k8s中的定时任务，守护进程，有状态应用，无状态应用等；服务发现对应k8s中的NodePort，Ingress等；存储对应k8s中的ConfigMap，存储卷等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> Rocky Linux </tag>
            
            <tag> rancher2.7.9 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s初窥之实战集群搭建</title>
      <link href="/2024/01/18/k8s%E5%88%9D%E7%AA%A5%E4%B9%8B%E5%AE%9E%E6%88%98%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/01/18/k8s%E5%88%9D%E7%AA%A5%E4%B9%8B%E5%AE%9E%E6%88%98%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  k8s集群搭建有2种方式，一种是通过二进制方式搭建，另一种是通过kubeadm命令行工具搭建，笔者此次主要是kubeadm命令行工具搭建k8s集群。</code></pre><blockquote><p>此次搭建的是k8s 1.28.5版本；官方文档地址：<a href="https://v1-28.docs.kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">https://v1-28.docs.kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/</a></p></blockquote><h3 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h3><blockquote><p>ip，hostname，防火墙，selinux，swap,docker等配置在前篇k8s初探之准备中已做好。</p></blockquote><h4 id="在3台机的hosts文件写入对应的ip和主机名映射、允许iptables检查桥接流量"><a href="#在3台机的hosts文件写入对应的ip和主机名映射、允许iptables检查桥接流量" class="headerlink" title="在3台机的hosts文件写入对应的ip和主机名映射、允许iptables检查桥接流量"></a>在3台机的hosts文件写入对应的ip和主机名映射、允许iptables检查桥接流量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  cat &gt;&gt; /etc/hosts &lt;&lt; EOF</span><br><span class="line">192.168.56.102 master</span><br><span class="line">192.168.56.103 node1</span><br><span class="line">192.168.56.104 node2</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>配置允许iptables 检查桥接流量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">  cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">  sysctl --system <span class="comment"># 立即生效</span></span><br></pre></td></tr></table></figure><h3 id="安装kubelet、kubeadm、kubectl"><a href="#安装kubelet、kubeadm、kubectl" class="headerlink" title="安装kubelet、kubeadm、kubectl"></a>安装kubelet、kubeadm、kubectl</h3><pre><code>你需要在每台机器上安装以下的软件包：kubeadm：用来初始化集群的指令。kubelet：在集群中的每个节点上用来启动 Pod 和容器等。kubectl：用来与集群通信的命令行工具。kubeadm 不能帮你安装或者管理 kubelet 或 kubectl， 所以你需要确保它们与通过 kubeadm 安装的控制平面的版本相匹配。 如果不这样做，则存在发生版本偏差的风险，可能会导致一些预料之外的错误和问题。 然而，控制平面与 kubelet 之间可以存在一个次要版本的偏差，但 kubelet 的版本不可以超过 API 服务器的版本。 例如，1.7.0 版本的 kubelet 可以完全兼容 1.8.0 版本的 API 服务器，反之则不可以。</code></pre><blockquote><p>以上这段话摘自官网，相关图示如下</p></blockquote><p>  <img src="/images/k8s_install_readme.jpeg" alt></p><p>  <img src="/images/k8s_install.jpeg" alt> </p><h4 id="添加-Kubernetes-的-yum-仓库"><a href="#添加-Kubernetes-的-yum-仓库" class="headerlink" title="添加 Kubernetes 的 yum 仓库"></a>添加 Kubernetes 的 yum 仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 此操作会覆盖 /etc/yum.repos.d/kubernetes.repo 中现存的所有配置</span></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://pkgs.k8s.io/core:/stable:/v1.28/rpm/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://pkgs.k8s.io/core:/stable:/v1.28/rpm/repodata/repomd.xml.key</span><br><span class="line">exclude=kubelet kubeadm kubectl cri-tools kubernetes-cni</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="安装-kubelet、kubeadm-和-kubectl，并启用-kubelet-以确保它在启动时自动启动"><a href="#安装-kubelet、kubeadm-和-kubectl，并启用-kubelet-以确保它在启动时自动启动" class="headerlink" title="安装 kubelet、kubeadm 和 kubectl，并启用 kubelet 以确保它在启动时自动启动"></a>安装 kubelet、kubeadm 和 kubectl，并启用 kubelet 以确保它在启动时自动启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line">systemctl <span class="built_in">enable</span> --now kubelet</span><br></pre></td></tr></table></figure><h3 id="使用-kubeadm-创建集群"><a href="#使用-kubeadm-创建集群" class="headerlink" title="使用 kubeadm 创建集群"></a>使用 kubeadm 创建集群</h3><blockquote><p><a href="https://v1-28.docs.kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">https://v1-28.docs.kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/</a></p></blockquote><p>  <img src="/images/k8s_init_master1.jpeg" alt> </p><p>所有机器添加master域名映射，以下需要修改为自己的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"192.168.56.102  cluster-endpoint"</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><p>master节点初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.56.102 \</span><br><span class="line">--control-plane-endpoint=cluster-endpoint \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version v1.28.5 \</span><br><span class="line">--service-cidr=10.96.0.0/12 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><blockquote><p>–apiserver-advertise-address值是master节点的ip地址，–control-plane-endpoint值是master节点的域名，必须和上一步写入hosts文件的值一致，–image-repository值是镜像仓库地址，–kubernetes-version值是k8s版本，–service-cidr值是service的网段，此值不要修改，–pod-network-cidr值是pod的网段，此值不要修改。–service-cidr、–pod-network-cidr、–apiserver-advertise-address三个的值保证各自在不同的网段即可，不要重叠。</p></blockquote><p>如果不出意外的话，就要出意外，意外如图：</p><p>  <img src="/images/k8s_init_error.jpeg" alt></p><p>查看错误提示信息，container run time is not runing.发现问题是在containerd，于是重新生成/etc/containerd/config.toml，把上面报错的“registry.k8s.io/pause:3.6”修改为阿里云的镜像，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">containerd config default | sudo tee /etc/containerd/config.toml <span class="comment">#重新生成/etc/containerd/config.toml</span></span><br><span class="line">sed -i <span class="string">'s#SystemdCgroup = false#SystemdCgroup = true#g'</span> /etc/containerd/config.toml</span><br><span class="line">sed -i <span class="string">'s#sandbox_image = "registry.k8s.io/pause:3.6"#sandbox_image = "registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.9"#g'</span> /etc/containerd/config.toml</span><br><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure><blockquote><p>Containerd是一个开源的容器运行时管理器，用于管理容器的生命周期，包括容器的创建、启动、停止、暂停和销毁。它是Docker Engine的核心组件之一，也是Kubernetes、CRI-O等容器平台的基础组件。k8s早期版本(1.23之前)采用Docker作为容器运行时；docker作为k8s容器运行时，调用关系为：kubelet –&gt; dockershim （在 kubelet 进程中） –&gt; dockerd –&gt; containerd；而containerd 作为 k8s 容器运行时，调用关系为：kubelet –&gt; cri plugin（在 containerd 进程中） –&gt; containerd；作为一个纯粹的容器运行时，Containerd被设计为更加符合K8s的架构和需求。它具有更小的资源占用，更快的启动时间，以及更好的性能表现。所以，节点只要装好containerd，也能运行k8s。(前文已装好docker(docker内含了containerd))</p></blockquote><p>执行上述操作后，再次执行kubeadm init命令，等一会后，k8s集群就初始化成功了。</p><p>记住上述圈着的几处地方，第一处提示节点初始化成功，然后执行第二处里面的相关命令，然后进入第三处的链接地址，安装网络组件，第四处是worker节点加入集群的命令，需要记录下来。然后开始安装网络组件：</p><p>k8s支持很多网络组件，地址如下：<a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/</a></p><p>  <img src="/images/k8s_net_plugins.jpeg" alt></p><p>此处我安装calico组件，对应的地址从上图链接进入官网首页，然后找到安装地址入口，最终地址如下：<a href="https://docs.tigera.io/calico/latest/getting-started/kubernetes/self-managed-onprem/onpremises#install-calico-with-kubernetes-api-datastore-more-than-50-nodes" target="_blank" rel="noopener">https://docs.tigera.io/calico/latest/getting-started/kubernetes/self-managed-onprem/onpremises#install-calico-with-kubernetes-api-datastore-more-than-50-nodes</a></p><p>  <img src="/images/k8s_calico_install.jpeg" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.githubusercontent.com/projectcalico/calico/v3.27.0/manifests/calico.yaml -O  <span class="comment"># 网络不好可以单独下载下来上传到master节点的某个目录</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f calico.yaml <span class="comment"># 在calico.yaml文件目录下执行</span></span><br></pre></td></tr></table></figure><p>安装成功如下</p><p>  <img src="/images/k8s_calico_success.jpeg" alt></p><p>执行 kubectl get nodes命令，查看集群节点情况，如下图</p><p>  <img src="/images/k8s_master_result.jpeg" alt></p><p>此时，master节点已全部部署成功，可以开始添加worker节点了。</p><blockquote><p>注意：高可用部署方式，也是在这一步的时候，使用添加主节点的命令即可</p></blockquote><p>执行上述master节点初始化成功截图的第四处命令，添加worker节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join cluster-endpoint:6443 --token kzbiee.o1nfrwwz5x8zshr3 \</span><br><span class="line">      --discovery-token-ca-cert-hash sha256:494621342b7b363815d711ac8f1677760d7e94b5a1fbdd84e042e983bdc94035</span><br></pre></td></tr></table></figure><p>不出意外，仍然会报containerd相关的错误</p><p>  <img src="/images/k8s_init_worker_error.jpeg" alt></p><p>在worker节点仍然执行对containerd问题的相关处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">containerd config default | sudo tee /etc/containerd/config.toml <span class="comment">#重新生成/etc/containerd/config.toml</span></span><br><span class="line">sed -i <span class="string">'s#SystemdCgroup = false#SystemdCgroup = true#g'</span> /etc/containerd/config.toml</span><br><span class="line">sed -i <span class="string">'s#sandbox_image = "registry.k8s.io/pause:3.6"#sandbox_image = "registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.9"#g'</span> /etc/containerd/config.toml</span><br><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure><p>再次执行kubeadm join 操作，即可。成功如下：</p><p>  <img src="/images/k8s_worker_success.jpeg" alt></p><p>默认的token时效是24小时，加入token失效，需要重新生成token，在master执行如下命令：</p><blockquote><p>kubeadm token create –print-join-command</p></blockquote><p>回到master节点，执行kubectl get nodes命令，查看worker节点是否成功加入集群，如下图</p><p>  <img src="/images/k8s_all_node_success.jpeg" alt></p><p>如果显示node1和node2是NotReady状态，需要等待一会。可以执行 kubectl get pods -A 查看所有pod的状态，如果当前所有pod状态都为Running，此时node1和node2的状态就会变为Ready。</p><p>  <img src="/images/k8s_all_node_pods.jpeg" alt>  </p><p>到此，k8s集群已经成功部署完毕。接下来，可以开始使用k8s部署项目了。k8s命令部署应用比较繁琐，接下来将集群导入到rancher(2.7.9)中，使用rancher来对k8s集群进行管理，后续会介绍rancher的相关导入及使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> Rocky Linux </tag>
            
            <tag> virtualbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s初窥之准备</title>
      <link href="/2024/01/17/k8s%E5%88%9D%E7%AA%A5%E4%B9%8B%E5%87%86%E5%A4%87/"/>
      <url>/2024/01/17/k8s%E5%88%9D%E7%AA%A5%E4%B9%8B%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  最近在学习了解k8s，将学习动手的过程记录下。首先需要一个集群环境，便使用virtualbox模拟集群环境；  由于centos停更（改为滚动更新的Stream版），所以系统采用Rocky Linux (9.3)。</code></pre><p>下面是对Rocky Linux的介绍，摘选自Rocky Linux的百度百科。</p><blockquote><p>Rocky Linux是一个开源、社区拥有和管理、免费的企业Linux发行版，提供强大的生产级平台。旨在与RHEL（Red Hat Enterprise Linux） 100%兼容。可作为CentOS停止维护（改为滚动更新的Stream版）后，RHEL的下游Linux操作系统替代方案，并继承了原CentOS的开源免费特点。</p></blockquote><h3 id="从Rocky-Linux的官方网站下载对应的镜像iso文件，下载Minimal版本，大约1-6G左右。"><a href="#从Rocky-Linux的官方网站下载对应的镜像iso文件，下载Minimal版本，大约1-6G左右。" class="headerlink" title="从Rocky Linux的官方网站下载对应的镜像iso文件，下载Minimal版本，大约1.6G左右。"></a>从Rocky Linux的官方网站下载对应的镜像iso文件，下载Minimal版本，大约1.6G左右。</h3><blockquote><p>官网地址：<a href="https://rockylinux.org/download" target="_blank" rel="noopener">https://rockylinux.org/download</a></p></blockquote><p> 下载页面如下图</p><p> <img src="/images/rocky_linux_download.jpeg" alt></p><h3 id="使用VirtualBox创建虚拟机并安装Rocky-Linux系统"><a href="#使用VirtualBox创建虚拟机并安装Rocky-Linux系统" class="headerlink" title="使用VirtualBox创建虚拟机并安装Rocky Linux系统"></a>使用VirtualBox创建虚拟机并安装Rocky Linux系统</h3><blockquote><p>k8s对机器有要求，建议最低2vCPU，内存的话笔者设置的3G，硬盘100G。</p></blockquote><p>  <img src="/images/k8s_req.jpeg" alt></p><p>  笔者这里准备3台虚拟机，1台用于部署k8s集群的master节点，另外2台作为node节点。对对于需要3台虚拟机，可以装好一台然后通过virtualbox的clone功能来创建另外2台（clone的过程中生成新的网卡MAC地址）。</p><p>  因为是集群环境，需要环境中的每台机器网络互通，并且还能访问外网。访问外网，此处使用NAT(网络地址转换)模式，集群内部的机器，使用Host-only模式。virtualbox全局对网络的设置如下图; dhcp配置与否，都可以，反正后续会把集群中的机器的ip设置成静态的。</p><p>  <img src="/images/virtual_host_only_global_cfg.jpeg" alt></p><p>  安装过程很简单，此处就不截图展示了。</p><h3 id="安装完之后"><a href="#安装完之后" class="headerlink" title="安装完之后"></a>安装完之后</h3><h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># systemctl status firewalld # Active显示running代表防火墙开启状态</span></span><br><span class="line">[root@master ~]<span class="comment"># systemctl stop firewalld # 停止防火墙</span></span><br><span class="line">[root@master ~]<span class="comment"># systemctl status firewalld # Active显示inactive代表防火墙关闭状态</span></span><br><span class="line">[root@master ~]<span class="comment"># systemctl disable firewalld # 关闭开启自启防火墙</span></span><br></pre></td></tr></table></figure><h4 id="设置hostname"><a href="#设置hostname" class="headerlink" title="设置hostname"></a>设置hostname</h4><p>  需要保证集群中的每台机器的hostname都不一样。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># hostnamectl set-hostname master #master 为主机名</span></span><br></pre></td></tr></table></figure><h4 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h4>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># swapoff -a  # 关闭swap，临时</span></span><br><span class="line">[root@master ~]<span class="comment"># sed -ri 's/.*swap.*/#&amp;/' /etc/fstab # 关闭swap，永久</span></span><br></pre></td></tr></table></figure><h4 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h4>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># setenforce 0 # 关闭selinux</span></span><br><span class="line">[root@master ~]<span class="comment"># sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config ## 将 SELinux 设置为 permissive 模式（相当于将其禁用）</span></span><br></pre></td></tr></table></figure><p>  或者通过修改/etc/selinux/config文件，将SELINUX的值改为disabled</p><h4 id="配置静态ip地址，以便于集群中机器的通信。"><a href="#配置静态ip地址，以便于集群中机器的通信。" class="headerlink" title="配置静态ip地址，以便于集群中机器的通信。"></a>配置静态ip地址，以便于集群中机器的通信。</h4><blockquote><p>在Rocky9中，丢弃使用了传统的network 而使用新的NetworkManager管理方式,较之前的版本配置方式有所不同</p></blockquote><p>先查看当前网卡的相关信息</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># ip addr</span></span><br><span class="line">  1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">      link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">      inet 127.0.0.1/8 scope host lo</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">      inet6 ::1/128 scope host </span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">  2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">      link/ether 08:00:27:9a:9d:14 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">      inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic noprefixroute enp0s3</span><br><span class="line">        valid_lft 86056sec preferred_lft 86056sec</span><br><span class="line">      inet6 fe80::a00:27ff:fe9a:9d14/64 scope link noprefixroute </span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">  3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">      link/ether 08:00:27:1a:1d:86 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">      inet 192.168.56.102/24 brd 192.168.56.255 scope global noprefixroute enp0s8</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">      inet6 fe80::a00:27ff:fe1a:1d86/64 scope link noprefixroute </span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">[root@master ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure></blockquote><p>找到virtualbox的host-only网卡对应的名字是enp0s8，然后进行设置静态ip</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># vim /etc/NetworkManager/system-connections/enp0s8.nmconnection</span></span><br></pre></td></tr></table></figure></blockquote><p>将[ipv4]下的内容修改为如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ipv4]</span><br><span class="line">method=manual <span class="comment"># 设置获取IP地址方式auto--&gt;manual</span></span><br><span class="line">address1=192.168.56.102/24,192.168.56.1 <span class="comment">#设置IP地址为192.168.56.102,掩码为255.255.255.0，可直接紧跟ip地址后写/24，网关地址为192.168.56.1</span></span><br></pre></td></tr></table></figure><p>重启网卡配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmcli c reload</span><br><span class="line">nmcli c up enp0s8</span><br></pre></td></tr></table></figure><blockquote><p>重新通过ip addr查看ip地址是否设置成功;</p></blockquote><blockquote><p><b>其他2台机器按照同样的流程进行配置。注意ip地址和主机名</b></p></blockquote><h4 id="开启ipv4转发"><a href="#开启ipv4转发" class="headerlink" title="开启ipv4转发"></a>开启ipv4转发</h4><blockquote><p>此项非必须，后续rancher相关操作时会用到，所以此处一起设置了</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># cat /proc/sys/net/ipv4/ip_forward #查看是否开启 ipv4 转发，结果为 1 则是已开启。</span></span><br><span class="line">[root@master ~]<span class="comment"># echo 'net.ipv4.ip_forward=1' &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line">[root@master ~] sysctl -p <span class="comment"># 重新加载配置</span></span><br></pre></td></tr></table></figure><p>或者直接编辑/etc/sysctl.conf文件，在文件中添加net.ipv4.ip_forward=1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># vim /etc/sysctl.conf</span></span><br><span class="line">[root@master ~] sysctl -p <span class="comment"># 重新加载配置</span></span><br></pre></td></tr></table></figure></p><p>配置好3台机器的网络信息后，可在3台机器上通过ping命令互相ping查看通讯是否正常。</p><p>笔者这里3台机（192.168.56.102、192.168.56.103、192.168.56.104）配置好的结果如下图：<br> <img src="/images/cluster_net_cfg.jpeg" alt></p><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>对3台机器进行docker安装。Rocky Linux兼容了Centos，所以安装docker的方法和Centos一致。详细过程可参考docker官网地址：<a href="https://docs.docker.com/engine/install/centos" target="_blank" rel="noopener">https://docs.docker.com/engine/install/centos</a></p><h4 id="Set-up-the-repository-设置添加docker仓库"><a href="#Set-up-the-repository-设置添加docker仓库" class="headerlink" title="Set up the repository 设置添加docker仓库"></a>Set up the repository 设置添加docker仓库</h4><p>Install the yum-utils package (which provides the yum-config-manager utility) and set up the repository.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># yum install -y yum-utils</span></span><br><span class="line">[root@master ~]<span class="comment"># yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure><h4 id="Install-Docker-Engine-安装docker引擎"><a href="#Install-Docker-Engine-安装docker引擎" class="headerlink" title="Install Docker Engine 安装docker引擎"></a>Install Docker Engine 安装docker引擎</h4><blockquote><p>注： 自2024年6月起，docker官方地址已经完全被墙了，国内安装docker需要添加国内的docker仓库源了</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># yum-config-manager --add--repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo //  阿里镜像源</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin  # 安装docker</span></span><br><span class="line">[root@master ~]<span class="comment"># systemctl start docker  # 启动docker</span></span><br><span class="line">[root@master ~]<span class="comment"># systemctl enable docker # 设置docker自启动</span></span><br><span class="line">[root@master ~]<span class="comment"># usermod -aG docker $USER  # 将当前用户加入docker用户组，这样当前用户就可以直接使用docker命令了</span></span><br><span class="line">[root@master ~]<span class="comment"># newgrp docker # 更新用户组docker,立即生效</span></span><br><span class="line">[root@master ~]<span class="comment"># docker version  # 查看docker版本</span></span><br><span class="line">[root@master ~]<span class="comment"># docker run hello-world  # 测试docker是否安装成功</span></span><br></pre></td></tr></table></figure><blockquote><p>为了后续下载镜像时方便，可以将docker镜像仓库地址设置为阿里云的镜像仓库，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># vim /etc/docker/daemon.json</span></span><br><span class="line">              &#123;</span><br><span class="line">                <span class="string">"registry-mirrors"</span>: [<span class="string">"https://xxxx.mirror.aliyuncs.com"</span>] // xxxx替换为自己的镜像仓库地址</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>重启docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line">[root@master ~]<span class="comment"># systemctl restart docker</span></span><br></pre></td></tr></table></figure><blockquote><p>注： 自2024年6月起，国内各大docker镜像仓库都不能访问了，拉取镜像需要科学上网；Docker容器和守护进程运行在一个隔离的环境中，默认情况下不会继承主机系统的代理设置，所以需要对其进行设置；docker代理分为docker-client的代理和docker-daemon的代理;</p></blockquote><p>client的代理可直接在/etc/docker/daemon.json文件中直接配置:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"proxies"</span>: &#123;</span><br><span class="line">      <span class="attr">"default"</span>: &#123;</span><br><span class="line">        <span class="attr">"httpProxy"</span>:<span class="string">""</span>,</span><br><span class="line">        "httpsProxy"："",</span><br><span class="line">        "noproxy"; "localhost,127.0.0.1,.example.com"</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>daemon的代理需要在系统服务中进行配置:</p><p>创建一个 Docker 配置文件（如果不存在），并在其中添加代理设置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># mkdir  /etc/systemd/system/docker.service.d </span></span><br><span class="line">[root@master ~]<span class="comment"># vim /etc/systemd/system/docker.service.d/proxy.conf</span></span><br></pre></td></tr></table></figure></p><p>在文件中添加以下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://proxy_server:port"</span></span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=http://proxy_server:port"</span></span><br><span class="line">Environment=<span class="string">"NO_PROXY=localhost,127.0.0.1"</span></span><br></pre></td></tr></table></figure></p><p>重启docker即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line">[root@master ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line">[root@master ~]<span class="comment"># docker info // 查看代理配置是否生效</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> Rocky Linux </tag>
            
            <tag> virtualbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot 接收参数统一除去参数值前后的空串</title>
      <link href="/2021/07/27/springboot-%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E7%BB%9F%E4%B8%80%E9%99%A4%E5%8E%BB%E5%8F%82%E6%95%B0%E5%80%BC%E5%89%8D%E5%90%8E%E7%9A%84%E7%A9%BA%E4%B8%B2/"/>
      <url>/2021/07/27/springboot-%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E7%BB%9F%E4%B8%80%E9%99%A4%E5%8E%BB%E5%8F%82%E6%95%B0%E5%80%BC%E5%89%8D%E5%90%8E%E7%9A%84%E7%A9%BA%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>springboot 接收参数统一除去参数值前后的空串</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span>(basePackages = &#123;<span class="string">"com.bz"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNoSpaceAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 去除get方式的参数空格</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> binder</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 String trim 编辑器</span></span><br><span class="line">        <span class="comment">// 构造方法中 boolean 参数含义为如果是空白字符串,是否转换为null</span></span><br><span class="line">        <span class="comment">// 即如果为true,那么 " " 会被转换为 null,否者为 ""</span></span><br><span class="line">        StringTrimmerEditor propertyEditor = <span class="keyword">new</span> StringTrimmerEditor(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 为 String 类对象注册编辑器</span></span><br><span class="line">        binder.registerCustomEditor(String<span class="class">.<span class="keyword">class</span>, <span class="title">propertyEditor</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 去除post/put requestBody实体中的空格</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Jackson2ObjectMapperBuilderCustomizer <span class="title">jackson2ObjectMapperBuilderCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jacksonObjectMapperBuilder -&gt; jacksonObjectMapperBuilder</span><br><span class="line">                .deserializerByType(String<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">StdScalarDeserializer</span>&lt;<span class="title">Object</span>&gt;(<span class="title">String</span>.<span class="title">class</span>) </span>&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(JsonParser jsonParser, DeserializationContext ctx)</span></span></span><br><span class="line"><span class="function">                            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> StringUtils.trimWhitespace(jsonParser.getValueAsString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js检测浏览器页面是否缩放</title>
      <link href="/2021/07/27/js%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%90%A6%E7%BC%A9%E6%94%BE/"/>
      <url>/2021/07/27/js%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%90%A6%E7%BC%A9%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用js前端检测浏览器的页面是否手工缩放</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * detectZoom 函数的返回值如果是 100 就是默认缩放级别，大于 100 则是放大了，小于 100 则是缩小了</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectZoom</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> ratio = <span class="number">0</span>,</span><br><span class="line">    screen = <span class="built_in">window</span>.screen,</span><br><span class="line">    ua = navigator.userAgent.toLowerCase();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      ratio = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (~ua.indexOf(<span class="string">'msie'</span>)) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (screen.deviceXDPI &amp;&amp; screen.logicalXDPI) &#123;</span><br><span class="line">      ratio = screen.deviceXDPI / screen.logicalXDPI;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.outerWidth !== <span class="literal">undefined</span> &amp;&amp; <span class="built_in">window</span>.innerWidth !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    ratio = <span class="built_in">window</span>.outerWidth / <span class="built_in">window</span>.innerWidth;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (ratio)&#123;</span><br><span class="line">    ratio = <span class="built_in">Math</span>.round(ratio * <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ratio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发学习入门-1</title>
      <link href="/2020/04/13/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-1/"/>
      <url>/2020/04/13/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-1/</url>
      
        <content type="html"><![CDATA[<h3 id="高并发-扩容"><a href="#高并发-扩容" class="headerlink" title="高并发 - 扩容"></a>高并发 - 扩容</h3><h4 id="垂直扩容-纵向扩展-提高系统部件能力"><a href="#垂直扩容-纵向扩展-提高系统部件能力" class="headerlink" title="垂直扩容(纵向扩展) : 提高系统部件能力"></a>垂直扩容(纵向扩展) : 提高系统部件能力</h4><p>比如:增加内存垂直扩容的主要是提高系统部件的能力,但会增大单个服务中其他软件设施的依赖与管理、服务内部复杂度</p><h4 id="水平扩容-横向扩展-增加更多系统成员来实现"><a href="#水平扩容-横向扩展-增加更多系统成员来实现" class="headerlink" title="水平扩容(横向扩展) : 增加更多系统成员来实现"></a>水平扩容(横向扩展) : 增加更多系统成员来实现</h4><p>比如:加服务器实现水平扩容主要是增加更多的成员来分担压力，但会增加网络、数据库 IO 开销、管理多个服务器的难度</p><h4 id="扩容-数据库"><a href="#扩容-数据库" class="headerlink" title="扩容 - 数据库"></a>扩容 - 数据库</h4><h5 id="读操作扩展"><a href="#读操作扩展" class="headerlink" title="读操作扩展"></a>读操作扩展</h5><p>加缓存,结合 memcathe、redis、CDN 等构建一个健壮的缓存系统。如果系统超负荷运行，将更多的数据放在缓存中来缓解系统的读压力。采用水平扩容没有太大的意义，因为性能的瓶颈不在写操作，所以不需要实时去完成，用更多的服务器来分担压力性价比太低。所以针对单个系统去强化它的读性能就可以了</p><h5 id="写操作扩展"><a href="#写操作扩展" class="headerlink" title="写操作扩展"></a>写操作扩展</h5><p>如 Cassandra、Hbase 等。和大多数的关系型数据库不同，这种数据存储会随着增长增加更多的节点。也可以考虑垂直扩容提升单个数据库的性能，但会发现资金与硬盘的 IO 能力是有限的，所以需要增加更多数据库来分担写的压力。</p><h3 id="高并发-缓存"><a href="#高并发-缓存" class="headerlink" title="高并发 - 缓存"></a>高并发 - 缓存</h3><p><img src="/images/cache.jpg" alt></p><h4 id="缓存特征"><a href="#缓存特征" class="headerlink" title="缓存特征"></a>缓存特征</h4><p>1.命中率 : 命中数/(命中数+未命中数)</p><p>2.最大元素(最大空间)</p><p>3.清空策略</p><h4 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h4><p>1.本地缓存</p><p>2.分布式缓存:Memcache,redis</p><h4 id="缓存常见问题"><a href="#缓存常见问题" class="headerlink" title="缓存常见问题"></a>缓存常见问题</h4><p>1.缓存一致性</p><p>数据库的数据和缓存中的数据保持一致.</p><p>2.缓存并发问题</p><p>获取缓存的时候加锁,获取完释放锁</p><p>3.缓存穿透</p><p>一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value，就应该去后端系统查找（比如 DB）。一些恶意的请求会故意查询不存在的 key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><p>如何避免？</p><p>3-1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理缓存。</p><p>3-2：对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过该 bitmap 过滤。</p><p>4.缓存雪崩</p><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p><p>如何避免？</p><p>4-1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</p><p>4-2：做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期</p><p>4-3：不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p><h3 id="高并发-消息队列"><a href="#高并发-消息队列" class="headerlink" title="高并发 - 消息队列"></a>高并发 - 消息队列</h3><h4 id="消息队列特征"><a href="#消息队列特征" class="headerlink" title="消息队列特征"></a>消息队列特征</h4><p>1.与业务无关,只做消息分发</p><p>2.FIFO.先投递先到达</p><p>3.容灾,节点的动态增删和消息的持久化</p><p>4.性能,吞吐量提升,系统内部效率提高</p><h4 id="消息队列的好处"><a href="#消息队列的好处" class="headerlink" title="消息队列的好处"></a>消息队列的好处</h4><p>1.解耦</p><p>2.削峰,流量控制</p><p>3.异步,最终一致性</p><p>4.广播</p><h3 id="高并发-应用拆分"><a href="#高并发-应用拆分" class="headerlink" title="高并发 - 应用拆分"></a>高并发 - 应用拆分</h3><p>拆分原则:</p><p>1.业务优先,确定业务边界</p><p>2.循序渐进,边拆分边测试</p><p>3.兼顾技术:重构,分层</p><p>4.可靠测试</p><p>拆分的思考：</p><p>1.应用之间的通信：RPC（dubbo 等）、消息队列<br>消息传输适用于传输数据包小但是数据量大，对实时性要求不高的场景。比如下单成功后通过短信通知用户。而选用 RPC 框架实时性更高一些。你应该知道的 RPC 原理</p><p>2.应用之间的数据库设计：每个应用都有独立的数据库</p><p>3.避免事务操作跨应用，分布式事务是一个非常消耗资源的问题。这样应用和应用的耦合度降低。</p><p>应用服务化(Dubbo RPC,Spring Cloud 微服务)</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程学习与入门-6</title>
      <link href="/2020/04/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%85%A5%E9%97%A8-6/"/>
      <url>/2020/04/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%85%A5%E9%97%A8-6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>多线程并发拓展</p></blockquote><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程</p><p>死锁发生的 4 个必要条件:</p><p>1.互斥条件,进程对所分配的资源进行排他性的使用,即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待</p><p>2.请求和保持条件,进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放</p><p>3.不剥夺条件,进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)</p><p>4.环路等待条件,存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求</p><pre><code>只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的死锁类</span></span><br><span class="line"><span class="comment"> * 当DeadLock类的对象flag==1时（td1），先锁定o1,睡眠500毫秒</span></span><br><span class="line"><span class="comment"> * 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2,睡眠500毫秒</span></span><br><span class="line"><span class="comment"> * td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定；</span></span><br><span class="line"><span class="comment"> * td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定；</span></span><br><span class="line"><span class="comment"> * td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//静态对象是类的所有对象共享的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object(), o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"flag:&#123;&#125;"</span>, flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    log.info(<span class="string">"1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    log.info(<span class="string">"0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeadLock td1 = <span class="keyword">new</span> DeadLock();</span><br><span class="line">        DeadLock td2 = <span class="keyword">new</span> DeadLock();</span><br><span class="line">        td1.flag = <span class="number">1</span>;</span><br><span class="line">        td2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。</span></span><br><span class="line">        <span class="comment">//td2的run()可能在td1的run()之前运行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(td1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(td2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程并发与线程安全总结"><a href="#多线程并发与线程安全总结" class="headerlink" title="多线程并发与线程安全总结"></a>多线程并发与线程安全总结</h3><p><img src="/images/thread-summary.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程学习与入门-5</title>
      <link href="/2020/04/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%85%A5%E9%97%A8-5/"/>
      <url>/2020/04/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%85%A5%E9%97%A8-5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>线程池</p></blockquote><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h4 id="new-Thread-弊端"><a href="#new-Thread-弊端" class="headerlink" title="new Thread 弊端"></a>new Thread 弊端</h4><p>1.每次 new Thread 新建对象,性能差</p><p>2.线程缺乏统一管理,可能无限制的新建线程,相互竞争,有可能占用过多系统资源导致死机或者 OOM</p><p>3.缺少更多功能,如更多执行,定期执行,线程中断</p><h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><p>1.重用存在的线程,减少对象创建,消亡的开销,性能佳</p><p>2.可有效控制最大并发线程数,提高系统资源利用率,同时可以避免过多资源竞争,避免阻塞</p><p>3.提供定时执行,定期执行,单线程,并发数控制等功能</p><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><pre><code>参数:corePoolSize: 核心线程数量maximumPoolSize: 线程最大线程数workQueue: 阻塞队列,存储等待执行的任务,很重要,会对线程池运行过程产生重大影响说明:如果运行线程数少于corePoolSize的时候,直接创建新线程来处理任务(即使线程池里面的其他线程是空闲状态的).如果运行线程数量大于等于corePoolSize并且小于maximumPoolSize的时候,只有当workQueue满的时候才会创建新的线程去处理任务.如果corePoolSize和maximumPoolSize相等的时候,则创建的线程池线程数是固定的,这时如果有新任务提交,如果workQueue还没满的时候,就把请求放到workQueue里面等待有空闲的线程去执行任务.如果运行的线程数大于maximumPoolSize并且workQueue也已经满的时候,那么就由拒绝策略指定的方式去处理任务keepAliveTime: 线程没有任务执行的时候自多保持多久时间终止unit: keepAliveTime的时间单位threadFactory: 线程工厂,用来创建线程rejectHandler: 当拒绝处理任务的时候的策略  jdk默认提供了四种拒绝策略：  CallerRunsPolicy - 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，  如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大  AbortPolicy - 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，  影响后续的任务执行。  DiscardPolicy - 直接丢弃，其他啥都没有  DiscardOldestPolicy -  当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入常用方法:execute() : 提交任务,交给线程池执行submit() : 提交任务,能够返回执行结果,execute+Futureshutdown(): 关闭线程池,等待任务都执行完shutdownNow(): 关闭线程池,不等待任务执行完getTaskCount(): 线程池已执行和未执行的任务总数getCompletedTaskCount():已完成的任务数量getPoolSize(): 线程池当前的线程数量getActiveCount(): 当前线程池中正在执行任务的线程数量</code></pre><h4 id="线程池-Executor-框架接口"><a href="#线程池-Executor-框架接口" class="headerlink" title="线程池 - Executor 框架接口"></a>线程池 - Executor 框架接口</h4><p>1.Executors.newCachedThreadPool 可缓存的线程池,，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程;它的线程数是最大的，无限的。但是核心线程数为 0，这没关系。这里要考虑线程的摧毁，因为不能够无限的创建新的线程，所以在一定时间内要摧毁空闲的线程</p><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// 放入10个任务</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;"</span>, index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Executors.newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待;传入一个固定的核心线程数,其核心线程数等于最大线程数，而且它们的线程数存活时间都是无限的.</p><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;"</span>, index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.Executors.newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行,内部有一个延时的阻塞队列来维护任务的进行.</p><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;"</span>, index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.Executors.newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行;其默认的时间参数为 0 意味着无限的生命，就不会被摧毁了</p><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        executorService.schedule(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//                log.warn("schedule run");</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;, 3, TimeUnit.SECONDS);</span></span><br><span class="line"></span><br><span class="line">    executorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.warn(<span class="string">"schedule run"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//        executorService.shutdown();</span></span><br><span class="line"></span><br><span class="line">    Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.warn(<span class="string">"timer run"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">new</span> Date(), <span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>5.Executors.newWorkStealingPool 是 JDK1.8 版本加入的一种线程池，stealing 翻译为抢断、窃取的意思，它实现的一个线程池和上面 4 种都不一样，用的是 ForkJoinPool 类;最明显的用意就是它是一个并行的线程池，参数中传入的是一个线程并发的数量，这里和之前就有很明显的区别，前面 4 种线程池都有核心线程数、最大线程数等等，而这就使用了一个并发线程数解决问题。该线程池不会保证任务的顺序执行，也就是 WorkStealing 的意思，抢占式的工作。</p><p>源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (parallelism,</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池的合理配置"><a href="#线程池的合理配置" class="headerlink" title="线程池的合理配置"></a>线程池的合理配置</h4><p>1.CPU 密集型任务,就需要尽量压榨 CPU,参考值可设置为 NCPU+1</p><p>2.IO 密集型任务,参考值可设置为 2 * NCPU</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程学习与入门-4</title>
      <link href="/2020/04/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%85%A5%E9%97%A8-4/"/>
      <url>/2020/04/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%85%A5%E9%97%A8-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>线程安全策略</p></blockquote><h4 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h4><p>不可变对象需要满足的条件</p><pre><code>1.对象创建以后其状态就不能修改2.对象所有域都是final类型3.对象是正确创建的(在对象创建期间,this引用没有逸出)</code></pre><p>final 关键字:类,方法,变量</p><pre><code>修饰类:不能被继承修饰方法:1.锁定方法不被继承类修改;2.提升运行效率(针对于早期版本jdk)修饰变量:修饰数据类型变量(一旦初始化便不能修改),引用类型变量(初始化之后不能再指向另外一个对象)</code></pre><p>声明不可变对象相关的集合类</p><p>Collections.unmodifiableXXX:Collection,List,Set…</p><p>Guava:ImmutableXXX:Collection,List,Set…</p><h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><p>线程封闭的几种实现方式</p><h5 id="Ad-hoc-线程封闭-程序控制实现-最糟糕的方式-忽略"><a href="#Ad-hoc-线程封闭-程序控制实现-最糟糕的方式-忽略" class="headerlink" title="Ad-hoc 线程封闭:程序控制实现,最糟糕的方式,忽略"></a>Ad-hoc 线程封闭:程序控制实现,最糟糕的方式,忽略</h5><h5 id="堆栈封闭-简单来说就是局部变量-无并发问题"><a href="#堆栈封闭-简单来说就是局部变量-无并发问题" class="headerlink" title="堆栈封闭:简单来说就是局部变量,无并发问题"></a>堆栈封闭:简单来说就是局部变量,无并发问题</h5><h5 id="ThreadLocal-线程封闭-特别好的封闭方法"><a href="#ThreadLocal-线程封闭-特别好的封闭方法" class="headerlink" title="ThreadLocal 线程封闭:特别好的封闭方法"></a>ThreadLocal 线程封闭:特别好的封闭方法</h5><h4 id="常见的线程不安全类与写法"><a href="#常见的线程不安全类与写法" class="headerlink" title="常见的线程不安全类与写法"></a>常见的线程不安全类与写法</h4><p>StringBuilder -&gt; StringBuffer</p><p>SimpleDateForamt -&gt; Joda-Time</p><p>ArrayList,HashSet,HashMap 等 Collections</p><p>先检查在执行:if(condition(a)){handle(a);}触发线程不安全</p><h4 id="同步容器-并不能完全的确保线程安全"><a href="#同步容器-并不能完全的确保线程安全" class="headerlink" title="同步容器,并不能完全的确保线程安全"></a>同步容器,并不能完全的确保线程安全</h4><p>ArrayList -&gt; Vector,Stack</p><p>HashMap -&gt; HashTable(key value 不能为 null)</p><p>Collections.synchronizedXXX(List,Set,Map)</p><h4 id="并发容器-J-U-C"><a href="#并发容器-J-U-C" class="headerlink" title="并发容器 J.U.C"></a>并发容器 J.U.C</h4><p>ArrayList -&gt;CopyOnWriteArrayList</p><p>HashSet,TreeSet -&gt; CopyOnWriteArraySet,ConcurrentSkipListSet (只能保证单一操作原子性,如 add,remove 是线程安全的,不能保证批量操作如 containAll 等的原子性,即批量操作是线程不安全的)</p><p>HashMap,TreeMap -&gt; ConcureentHashMap,ConcurrentSkipListMap</p><h4 id="AbstractQueuedSynchronizer-AQS"><a href="#AbstractQueuedSynchronizer-AQS" class="headerlink" title="AbstractQueuedSynchronizer - AQS"></a>AbstractQueuedSynchronizer - AQS</h4><p><img src="/images/AQS.jpg" alt></p><p>使用 Node 实现 FIFO 队列,可以用于构建锁或者其他同步装置的基础框架</p><p>利用了一个 int 类型表示状态</p><p>使用方法是继承,子类通过继承并通过实现它 的方法管理其状态{acquire 和 release}的方法是操纵状态</p><p>可以同时实现排它锁和共享锁模式(独占,共享)</p><h5 id="AQS-同步组件"><a href="#AQS-同步组件" class="headerlink" title="AQS 同步组件"></a>AQS 同步组件</h5><p>CountDownLatch (通过计数来表示线程是否需要一直阻塞)</p><p>Semaphore (控制同一时间线程并发的数目)</p><p>CycliBarrier</p><p>ReentrantLock</p><p>Condition</p><p>FutureTask</p><p>…</p><h6 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h6><blockquote><p>通过计数来表示线程是否需要一直阻塞<br><img src="/images/CountDownLatch.jpg" alt></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">          exec.execute(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  test(threadNum);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  countDownLatch.countDown(); <span class="comment">// -1</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      countDownLatch.await(); <span class="comment">// 保证所有的线程执行完</span></span><br><span class="line">      <span class="comment">// countDownLatch.await(10, TimeUnit.MILLISECONDS); // 指定当前线程等待的时间,超过时间后当前线程继续向后执行,线程池内没执行完的会继续执行</span></span><br><span class="line">      log.info(<span class="string">"finish"</span>);</span><br><span class="line">      exec.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Thread.sleep(<span class="number">100</span>);</span><br><span class="line">      log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">      Thread.sleep(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h6 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h6><blockquote><p>控制同一时间线程并发的数目</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">          exec.execute(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">                  <span class="comment">// semaphore.acquire(3); // 获取多个许可</span></span><br><span class="line">                  test(threadNum);</span><br><span class="line">                  semaphore.release(); <span class="comment">// 释放一个许可</span></span><br><span class="line">                  <span class="comment">// semaphore.release(3); // 释放多个许可</span></span><br><span class="line"></span><br><span class="line">                  <span class="comment">/**</span></span><br><span class="line"><span class="comment">                  if (semaphore.tryAcquire()) &#123; // 尝试获取一个许可</span></span><br><span class="line"><span class="comment">                      test(threadNum);</span></span><br><span class="line"><span class="comment">                      semaphore.release(); // 释放一个许可</span></span><br><span class="line"><span class="comment">                  &#125;</span></span><br><span class="line"><span class="comment">                  **/</span></span><br><span class="line">                  <span class="comment">/**</span></span><br><span class="line"><span class="comment">                   if (semaphore.tryAcquire(5000, TimeUnit.MILLISECONDS)) &#123; // 尝试获取一个许可</span></span><br><span class="line"><span class="comment">                      test(threadNum);</span></span><br><span class="line"><span class="comment">                      semaphore.release(); // 释放一个许可</span></span><br><span class="line"><span class="comment">                  &#125;</span></span><br><span class="line"><span class="comment">                  **/</span></span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      exec.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h6 id="CycliBarrier"><a href="#CycliBarrier" class="headerlink" title="CycliBarrier"></a>CycliBarrier</h6><pre><code>和CountDownLatch一样使用计数器实现区别:  1.可以通过reset()重置计数器循环使用.CountDownLatch的计数器只能使用一次.  2.CountDownLatch主要是实现一个或n个线程需要等到其他线程完成操作后才能继续执行,标示的是一个或n个线程等待其他线程的关系;而CycliBarrier主要是实现了多个线程  之间的相互等待,直到所有的线程都满足了某个屏障点后再进行后续的操作,标示的是各个线程之间相互等待的关系.</code></pre><blockquote><p><img src="/images/CycliBarrier.gif" alt></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">// 指定一个runable,线程进入ready后,优先执行runable</span></span><br><span class="line"><span class="comment">  private static CyclicBarrier barrier = new CyclicBarrier(5, () -&gt; &#123;</span></span><br><span class="line"><span class="comment">     log.info("callback is running");</span></span><br><span class="line"><span class="comment"> &#125;);</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">     ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">         Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">         executor.execute(() -&gt; &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 race(threadNum);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     executor.shutdown();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">     log.info(<span class="string">"&#123;&#125; is ready"</span>, threadNum);</span><br><span class="line">     barrier.await();</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">       // 为了不影响后续执行,需要捕捉抛出的异常</span></span><br><span class="line"><span class="comment">       try &#123;</span></span><br><span class="line"><span class="comment">         barrier.await(2000, TimeUnit.MILLISECONDS);</span></span><br><span class="line"><span class="comment">       &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">           log.warn("BarrierException", e);</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">     log.info(<span class="string">"&#123;&#125; continue"</span>, threadNum);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h6 id="ReentrantLock-与锁"><a href="#ReentrantLock-与锁" class="headerlink" title="ReentrantLock 与锁"></a>ReentrantLock 与锁</h6><blockquote><p>java 中有两类锁,一类是 synchronized 关键字,一类就是 juc 中的锁</p></blockquote><pre><code>ReentrantLock(可重入锁)和synchronized区别1.可重入性2.锁的实现.synchronized依赖JVM,而ReentrantLock是jdk实现的3.性能的区别,synchronized未优化前,性能差很多.但是从synchronized引入偏向锁(轻量级锁也就是自旋锁)后,两者的性能差不多.4.功能区别,synchronized使用方便,不需要手动释放锁,JVM会自动释放,不会造成死锁.而ReentrantLock需要手工加锁和释放锁,不释放会造成死锁;灵活度上ReentrantLock优越于synchronizedReentrantLock独有的功能:1.可指定是公平锁(先等待的线程先获得锁)还是非公平锁2.提供了Condition类,可以分组唤醒需要唤醒的线程3.提供能够中断等待锁的线程的机制,调用lock.lockInterruptibly()来实现</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求总数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"><span class="comment">// 同时并发执行的线程数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                add();</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock读锁和写锁  (读锁很多,写锁很少的时候,会造成写锁一直等待,获取不到造成写锁饥饿)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock readLock = lock.readLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getAllKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StampdLock</span></span><br><span class="line">  <span class="comment">// 请求总数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">  <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">      <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">      <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">          executorService.execute(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  semaphore.acquire();</span><br><span class="line">                  add();</span><br><span class="line">                  semaphore.release();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">              countDownLatch.countDown();</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      countDownLatch.await();</span><br><span class="line">      executorService.shutdown();</span><br><span class="line">      log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> stamp = lock.writeLock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          count++;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock(stamp);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StampdLock 乐观锁和悲观锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123; <span class="comment">// an exclusively locked method</span></span><br><span class="line">          <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              x += deltaX;</span><br><span class="line">              y += deltaY;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              sl.unlockWrite(stamp);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//下面看看乐观读锁案例</span></span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// A read-only method</span></span><br><span class="line">          <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//获得一个乐观读锁</span></span><br><span class="line">          <span class="keyword">double</span> currentX = x, currentY = y;  <span class="comment">//将两个字段读入本地局部变量</span></span><br><span class="line">          <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">//检查发出乐观读锁后同时是否有其他写锁发生？</span></span><br><span class="line">              stamp = sl.readLock();  <span class="comment">//如果没有，我们再次获得一个读悲观锁</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  currentX = x; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                  currentY = y; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  sl.unlockRead(stamp);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//下面是悲观读锁案例</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">          <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">          <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123; <span class="comment">//循环，检查当前状态是否符合</span></span><br><span class="line">                  <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp); <span class="comment">//将读锁转为写锁</span></span><br><span class="line">                  <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123; <span class="comment">//这是确认转为写锁是否成功</span></span><br><span class="line">                      stamp = ws; <span class="comment">//如果成功 替换票据</span></span><br><span class="line">                      x = newX; <span class="comment">//进行状态改变</span></span><br><span class="line">                      y = newY;  <span class="comment">//进行状态改变</span></span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果不能成功转换为写锁</span></span><br><span class="line">                      sl.unlockRead(stamp);  <span class="comment">//我们显式释放读锁</span></span><br><span class="line">                      stamp = sl.writeLock();  <span class="comment">//显式直接进行写锁 然后再通过循环再试</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              sl.unlock(stamp); <span class="comment">//释放读锁或写锁</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>使用总结:</p><p>1.当只有少量线程竞争的时候,推荐使用 synchronized 锁实现</p><p>2.线程竞争量不少,但是线程增长量是在能预估的情况下,使用 ReentrantLock 实现</p><h6 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">      Condition condition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              reentrantLock.lock();</span><br><span class="line">              log.info(<span class="string">"wait signal"</span>); <span class="comment">// 1</span></span><br><span class="line">              condition.await();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          log.info(<span class="string">"get signal"</span>); <span class="comment">// 4</span></span><br><span class="line">          reentrantLock.unlock();</span><br><span class="line">      &#125;).start();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          reentrantLock.lock();</span><br><span class="line">          log.info(<span class="string">"get lock"</span>); <span class="comment">// 2</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          condition.signalAll();</span><br><span class="line">          log.info(<span class="string">"send signal ~ "</span>); <span class="comment">// 3</span></span><br><span class="line">          reentrantLock.unlock();</span><br><span class="line">      &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行结果:wait signal -&gt; get lock -&gt; send signal -&gt; get signal</span></span><br></pre></td></tr></table></figure><h6 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h6><p>Callable 与 Runable 接口对比:</p><pre><code>相同点：两者都是接口；两者都可用来编写多线程程序；两者都需要调用Thread.start()启动线程；不同点：两者最大的不同点是：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；</code></pre><p>Future 接口:</p><pre><code>Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取到结果；当不调用此方法时，主线程不会阻塞！</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">    log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    String result = future.get();</span><br><span class="line">    log.info(<span class="string">"result：&#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    运行结果:</span></span><br><span class="line"><span class="comment">    do something in callable</span></span><br><span class="line"><span class="comment">    do something in main</span></span><br><span class="line"><span class="comment">    result: Done</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">    log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    String result = futureTask.get();</span><br><span class="line">    log.info(<span class="string">"result：&#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    运行结果:</span></span><br><span class="line"><span class="comment">    do something in callable</span></span><br><span class="line"><span class="comment">    do something in main</span></span><br><span class="line"><span class="comment">    result: Done</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h6 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork/Join 框架"></a>Fork/Join 框架</h6><blockquote><p>java7 提供的一个并行执行任务的框架,把大任务分割成 N 个小任务,最后将小任务结果合并<br><img src="/images/fork-join.png" alt></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Slf</span>4j</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTaskExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinTaskExample</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果任务足够小就计算任务</span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (end - start) &lt;= threshold;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinTaskExample leftTask = <span class="keyword">new</span> ForkJoinTaskExample(start, middle);</span><br><span class="line">            ForkJoinTaskExample rightTask = <span class="keyword">new</span> ForkJoinTaskExample(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待任务执行结束合并其结果</span></span><br><span class="line">            <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">            <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkjoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一个计算任务，计算1+2+3+4</span></span><br><span class="line">        ForkJoinTaskExample task = <span class="keyword">new</span> ForkJoinTaskExample(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkjoinPool.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"result:&#123;&#125;"</span>, result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="BolckingQueue"><a href="#BolckingQueue" class="headerlink" title="BolckingQueue"></a>BolckingQueue</h6><blockquote><p>BlockingQueue 是阻塞队列，利用 ReentrantLock 的接口实现 ，依据它的基本原理，我们可以实现经典的生产者与消费者模式<br><img src="/images/BolckingQueue.png" alt></p></blockquote><p>相关实现类:</p><p>ArrayBlockingQueue: 有界(容量是有限的)阻塞队列,内部实现是数组.初始化指定容量大小,先进先出的方式存储数据.最先插入的是尾部,最先移除的是头部.</p><p>DelayQueue:提供了在指定时间才能获取队列元素的功能，队列头元素是最接近过期的元素。没有过期元素的话，使用 poll()方法会返回 null 值，超时判定是通过 getDelay(TimeUnit.NANOSECONDS)方法的返回值小于等于 0 来判断。延时队列不能存放空元素。延时队列实现了 Iterator 接口，但 iterator()遍历顺序不保证是元素的实际存放顺序。其队列元素需要实现 Delayed 接口</p><p>LinkedBlockingQueue:大小配置是可选的,初始化指定大小则是有边界的,如果不指定则是无边界(容量使用的是 Integer.MAX_VALUE).内部实现是一个链表.先进先出的方式存储数据.最先插入的是尾部,最先移除的是头部.</p><p>PriorityBlockingQueue:带有优先级的队列,是一个无边界的队列.允许插入 null.通过构造函数传入的对象来判断，传入的对象必须实现 comparable 接口。对象排序的规则就是在 comparable 中的规则.</p><p>SynchronousQueue:又称为同步队列,无界非缓存队列.内部只能包含一个元素的队列。插入元素到队列的线程被阻塞，直到另一个线程从队列中获取了队列中存储的元素。同样，如果线程尝试获取元素并且当前不存在任何元素，则该线程将被阻塞，直到线程将元素插入队列。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程学习与入门-3</title>
      <link href="/2020/03/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%85%A5%E9%97%A8-3/"/>
      <url>/2020/03/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%85%A5%E9%97%A8-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>安全发布对象</p></blockquote><h3 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h3><p>发布对象:使一个对象能够被当前范围之外的代码所使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String[] states = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> String[] getStates() &#123;</span><br><span class="line">    <span class="keyword">return</span> states;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    UnsafePublish unsafePublish = <span class="keyword">new</span> UnsafePublish();</span><br><span class="line">    log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line"></span><br><span class="line">    unsafePublish.getStates()[<span class="number">0</span>] = <span class="string">"d"</span>; <span class="comment">// 不安全的,通过public的getStates拿到states,可以对其更改</span></span><br><span class="line">    log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStates()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象逸出:一种错误的发布.当一个对象还没有构造完成时,就使它被其他线程所见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> thisCanBeEscape = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Escape</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> InnerClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Escape.<span class="keyword">this</span>.thisCanBeEscape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Escape();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安全发布对象"><a href="#安全发布对象" class="headerlink" title="安全发布对象"></a>安全发布对象</h3><p>有 4 种方法安全发布对象,比如单例模式的饿汉模式(线程安全),普通懒汉模式(线程不安全),懒汉双重锁检验模式(线程不安全),饿汉静态代码库模式(线程安全,注意静态域和静态代码块的执行先后顺序),懒汉双重锁检验+volatile 禁止指令重排序模式(线程安全),枚举模式(线程安全)</p><p>1.在静态初始化函数中初始化一个对象的引用</p><p>2.将对象的引用保存到 volatile 类型域或者 AtomicReference 对象中</p><p>3.将对象的引用保存到某个正确构造对象的 final 类型域中</p><p>4.将对象的引用保存到由一个锁保护的域中</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程学习与入门-2</title>
      <link href="/2020/03/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%85%A5%E9%97%A8-2/"/>
      <url>/2020/03/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%85%A5%E9%97%A8-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>线程安全性学习</p></blockquote><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>定义:当多个线程访问某个类时,不管运行时环境采用何种调度方式或者这些进程将如何交替执行,并且在主调代码中不需要任何额外的同步或协调,这个类都能表现出正确的行为,那么就称这个类是线程安全的.</p><p>主要体现在 3 个方面</p><p>1.原子性:提供了互斥访问,同一时刻只能有一个线程来对它进行操作</p><p>2.可见性:一个线程对主内存的修改可以及时的被其他线程观察到</p><p>3.有序性:一个线程观察其他线程中的指令执行顺序,由于指令重排序的存在,该观察结果一般杂乱无序.</p><h4 id="原子性-Atomic-包"><a href="#原子性-Atomic-包" class="headerlink" title="原子性 - Atomic 包"></a>原子性 - Atomic 包</h4><p>AtomicXXX: CAS(Unsafe.compareAndSwapInt()实现,原理:只有当工作内存的值和主内存的值是一致的时候,才会执行对应操作,否则不会执行)</p><p>AtomicInteger</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;<span class="comment">// 请求总数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;<span class="comment">// 同时并发执行的线程数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                add();</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    log.info(<span class="string">"count:&#123;&#125;"</span>, count.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count.incrementAndGet();</span><br><span class="line">    <span class="comment">// count.getAndIncrement();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AtomicXXX-相关的类"><a href="#AtomicXXX-相关的类" class="headerlink" title="AtomicXXX 相关的类:"></a>AtomicXXX 相关的类:</h4><h5 id="AtomicLong-LongAdder-jdk1-8-新增-可理解为-AtomicLong-的优化版"><a href="#AtomicLong-LongAdder-jdk1-8-新增-可理解为-AtomicLong-的优化版" class="headerlink" title="AtomicLong,LongAdder(jdk1.8 新增,可理解为 AtomicLong 的优化版)"></a>AtomicLong,LongAdder(jdk1.8 新增,可理解为 AtomicLong 的优化版)</h5><p>AtomicLong</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;<span class="comment">// 请求总数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;<span class="comment">// 同时并发执行的线程数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicLong count = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                add();</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    log.info(<span class="string">"count:&#123;&#125;"</span>, count.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count.incrementAndGet();</span><br><span class="line">    <span class="comment">// count.getAndIncrement();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LongAdder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;<span class="comment">// 请求总数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;<span class="comment">// 同时并发执行的线程数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LongAdder count = <span class="keyword">new</span> LongAdder();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                add();</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count.increment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="为什么要引入-LongAdder？"><a href="#为什么要引入-LongAdder？" class="headerlink" title="为什么要引入 LongAdder？"></a>为什么要引入 LongAdder？</h6><p>AtomicLong 是利用了底层的 CAS 操作来提供并发性的，比如 addAndGet 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> var6;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var6 = <span class="keyword">this</span>.getLongVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line">    <span class="keyword">return</span> var6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法调用了 Unsafe 类的 getAndAddLong 方法，该方法是个 native 方法，它的逻辑是采用自旋的方式不断更新目标值，直到更新成功。在并发量较低的环境下，线程冲突的概率比较小，自旋的次数不会很多。但是，高并发环境下，N 个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时 AtomicLong 的自旋会成为瓶颈。<br>这就是 LongAdder 引入的初衷——解决高并发环境下 AtomicLong 的自旋瓶颈问题</p><h6 id="LongAdder-快在哪里？"><a href="#LongAdder-快在哪里？" class="headerlink" title="LongAdder 快在哪里？"></a>LongAdder 快在哪里？</h6><p>既然说到 LongAdder 可以显著提升高并发环境下的性能，那么它是如何做到的？这里先简单的说下 LongAdder 的思路，第二部分会详述 LongAdder 的原理。</p><p>我们知道，AtomicLong 中有个内部变量 value 保存着实际的 long 值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value 变量其实是一个热点，也就是 N 个线程竞争一个热点。</p><p>LongAdder 的基本思路就是分散热点，将 value 值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行 CAS 操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的 long 值，只要将各个槽中的变量值累加返回。</p><p>这种做法有没有似曾相识的感觉？没错，ConcurrentHashMap 中的“分段锁”其实就是类似的思路。</p><h6 id="LongAdder-原理"><a href="#LongAdder-原理" class="headerlink" title="LongAdder 原理"></a>LongAdder 原理</h6><p>AtomicLong 是多个线程针对单个热点值 value 进行原子操作。而 LongAdder 是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行 CAS 操作。</p><p>比如有三个 ThreadA、ThreadB、ThreadC，每个线程对 value 增加 10。<br>对于 AtomicLong，最终结果的计算始终是下面这个形式： value=10+10+10=30</p><p>但是对于 LongAdder 来说，内部有一个 base 变量，一个 Cell[]数组;</p><p>base 变量：非竞态条件下，直接累加到该变量上;</p><p>Cell[]数组：竞态条件下，累加个各个线程自己的槽 Cell[i]中</p><p>最终结果的计算是下面这个形式：value=base+(Cell 数组从下标 0 到 n 的和)</p><p>LongAdder 只有一个空构造器，其本身也没有什么特殊的地方，所有复杂的逻辑都在它的父类 Striped64 中.大致原理如下:</p><p>将AtomicLong的内部核心数据value分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字进行计数，而最终的计数结果，则为这个数组的求和累加。热点数据value被分离成多个单元cell，每个cell独自维护内部的值，当前对象的实际值由所有的cell累计合成，这样热点就进行了有效的分离，提高了并行度。</p><pre><code>LongAdder设计的精妙之处：尽量减少热点冲突，不到最后万不得已，尽量将CAS操作延迟。</code></pre><h5 id="AtomicReference-AtomicReferenceFieldUpdater"><a href="#AtomicReference-AtomicReferenceFieldUpdater" class="headerlink" title="AtomicReference,AtomicReferenceFieldUpdater"></a>AtomicReference,AtomicReferenceFieldUpdater</h5><p>AtomicReference<integer></integer></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; count = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    count.compareAndSet(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line">    count.compareAndSet(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// no</span></span><br><span class="line">    count.compareAndSet(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// no</span></span><br><span class="line">    count.compareAndSet(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 4</span></span><br><span class="line">    count.compareAndSet(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// no</span></span><br><span class="line">    log.info(<span class="string">"count:&#123;&#125;"</span>, count.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicReferenceFieldUpdater(Class)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;AtomicDemo&gt; updater =</span><br><span class="line">        AtomicIntegerFieldUpdater.newUpdater(AtomicDemo.class, "count"); // count对应下面的count字段</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">100</span>; <span class="comment">// 必须是volatile修饰的字段</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AtomicDemo demo = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">    <span class="keyword">if</span> (updater.compareAndSet(demo, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">        log.info(<span class="string">"update success 1, &#123;&#125;"</span>, demo.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (updater.compareAndSet(demo, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">        log.info(<span class="string">"update success 2, &#123;&#125;"</span>, demo.getCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"update failed, &#123;&#125;"</span>, demo.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AtomicStampReference-CAS-的-ABA-问题"><a href="#AtomicStampReference-CAS-的-ABA-问题" class="headerlink" title="AtomicStampReference:CAS 的 ABA 问题"></a>AtomicStampReference:CAS 的 ABA 问题</h5><p>ABA 问题描述:</p><p>例如有 2 个线程同时对同一个值(初始值为 A)进行 CAS 操作，这三个线程如下,线程 1，期望值为 A，欲更新的值为 B;线程 2，期望值为 A，欲更新的值为 B;线程 1 抢先获得 CPU 时间片，而线程 2 因为其他原因阻塞了，线程 1 取值与期望的 A 值比较，发现相等然后将值更新为 B，然后这个时候出现了线程 3，期望值为 B，欲更新的值为 A，线程 3 取值与期望的值 B 比较，发现相等则将值更新为 A，此时线程 2 从阻塞中恢复，并且获得了 CPU 时间片，这时候线程 2 取值与期望的值 A 比较，发现相等则将值更新为 B，虽然线程 2 也完成了操作，但是线程 2 并不知道值已经经过了 A-&gt;B-&gt;A 的变化过程</p><p>比如:在提款机，提取了 50 元，因为提款机问题，有两个线程，同时把余额从 100 变为 50<br>线程 1（提款机）：获取当前值 100，期望更新为 50，<br>线程 2（提款机）：获取当前值 100，期望更新为 50，<br>线程 1 成功执行，线程 2 某种原因 block 了，这时，某人给小明汇款 50<br>线程 3（默认）：获取当前值 50，期望更新为 100，<br>这时候线程 3 成功执行，余额变为 100，<br>线程 2 从 Block 中恢复，获取到的也是 100，compare 之后，继续更新余额为 50！！！<br>此时可以看到，实际余额应该为 100（100-50+50），但是实际上变为了 50（100-50+50-50）这就是 ABA 问题带来的成功提交。</p><p>解决方法： 在变量前面加上版本号，每次变量更新的时候变量的版本号都+1，即 A-&gt;B-&gt;A 就变成了 1A-&gt;2B-&gt;3A</p><h4 id="原子性-锁"><a href="#原子性-锁" class="headerlink" title="原子性 - 锁"></a>原子性 - 锁</h4><h5 id="synchronized-依赖-JVM-子类继承-synchronized-的方法的时候-子类是不含-synchronized-的-必须手动声明-synchronized"><a href="#synchronized-依赖-JVM-子类继承-synchronized-的方法的时候-子类是不含-synchronized-的-必须手动声明-synchronized" class="headerlink" title="synchronized: 依赖 JVM,子类继承 synchronized 的方法的时候,子类是不含 synchronized 的,必须手动声明 synchronized"></a>synchronized: 依赖 JVM,子类继承 synchronized 的方法的时候,子类是不含 synchronized 的,必须手动声明 synchronized</h5><p>修饰代码块: 修饰范围是大括号括起来的代码,作用于调用的对象,不同对象之间不影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰一个代码块</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"test1 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample1 example1 = <span class="keyword">new</span> SynchronizedExample1();</span><br><span class="line">    SynchronizedExample1 example2 = <span class="keyword">new</span> SynchronizedExample1();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        example1.test1(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        example2.test1(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰方法:修饰范围是整个方法,作用于调用的对象,不同对象之间不影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        log.info(<span class="string">"test2 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample1 example1 = <span class="keyword">new</span> SynchronizedExample1();</span><br><span class="line">    SynchronizedExample1 example2 = <span class="keyword">new</span> SynchronizedExample1();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        example1.test2(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        example2.test2(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰静态方法:修饰范围是整个静态方法,作用于所有对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰一个类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample2<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"test1 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample2 example1 = <span class="keyword">new</span> SynchronizedExample2();</span><br><span class="line">    SynchronizedExample2 example2 = <span class="keyword">new</span> SynchronizedExample2();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        example1.test1(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        example2.test1(<span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰类:修饰范围是 class 括起来的部分,作用于所有对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰一个静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        log.info(<span class="string">"test2 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample2 example1 = <span class="keyword">new</span> SynchronizedExample2();</span><br><span class="line">    SynchronizedExample2 example2 = <span class="keyword">new</span> SynchronizedExample2();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        example1.test2(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        example2.test2(<span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Lock-依赖特殊的-CPU-指令-代码实现-ReentrantLock"><a href="#Lock-依赖特殊的-CPU-指令-代码实现-ReentrantLock" class="headerlink" title="Lock:依赖特殊的 CPU 指令,代码实现,ReentrantLock"></a>Lock:依赖特殊的 CPU 指令,代码实现,ReentrantLock</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> Lock lock;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reentantLocks</span><span class="params">()</span></span>&#123;</span><br><span class="line"> lock = (Lock) <span class="keyword">new</span> ReentantLock();</span><br><span class="line"> doStart();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//同步代码块</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原子性对比:</p><p>synchronized:不可中断锁,适合竞争不激烈,可读性好,JVM 自动释放锁<br>Lock:可中断锁,多样化同步,竞争激烈时能维持常态,必须手工释放锁</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>导致共享变量在线程间不可见的原因可能有:</p><p>1.线程交叉执行</p><p>2.重排序结合线程交叉执行</p><p>3.共享变量更新后的值没有在工作内存与主内存间及时更新</p><h5 id="synchronized-具有可见性和原子性"><a href="#synchronized-具有可见性和原子性" class="headerlink" title="synchronized,具有可见性和原子性"></a>synchronized,具有可见性和原子性</h5><p>JMM 关于 synchronized 的两条规定:</p><p>1.线程解锁钱,必须把共享变量的最新值刷新到主内存</p><p>2.线程加锁时,将清空工作内存中共享变量的值,从而使用共享变量时需要从主内存中重新读取最新的值(注意:加锁与解锁是同一把锁)</p><h5 id="volatile-不具有原子性"><a href="#volatile-不具有原子性" class="headerlink" title="volatile,不具有原子性"></a>volatile,不具有原子性</h5><p>通过加入内存屏障和禁止重排序优化来实现</p><p>对 volatile 变量写操作时,会在写操作后加入一条 store 屏障指令,将本地内存中的共享变量值刷新到主内存中去</p><p><img src="/images/volatile-write.png" alt></p><p>对 volatile 变量读操作时,会在读操作前加入一条 load 屏障指令,从主内存中读取共享比变量</p><p><img src="/images/volatile-read.png" alt></p><p>使用 volatile 必须依赖的原则:1.对变量的写操作不依赖当前值;2 该变量没有包含具有其他变量的不必要的式子中.</p><p>volatile 适用的场景:1.作为状态标记量;2.double check(双重检查)</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>在 JMM 中,允许编译器和处理器对指令进行重排序,但是重排序过程不会影响到单线程的执行,却会影响到多线程并发执行的正确性</p><p>Java 中,volatile,synchronized,lock 都能保持有序性</p><p>有序性的八条原则(happens-before 原则):</p><p>1.程序次序原则:单个线程内,按照代码顺序,书写在前面的操作先行发生于书写在后面的操作</p><p>2.锁定规则:一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</p><p>3.volatile 变量原则:对一个变量的写操作先行发生于后面对这个变量的读操作</p><p>4.传递原则:如果操作 A 先行发生于操作 B,而操作 B 又先行发生于操作 C,则可以得出操作 A 先行发生于操作 C</p><p>5.线程启动规则:Thread 对象 的 start()方法先行发生于此线程的每一个动作</p><p>6.线程中断原则:对线程的 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p><p>7.线程终结规则:线程中所有的操作都先行发生于线程的终止检测,我们可以通过 Thread.join()方法结束,Thread.isAlive()的返回值手段检测到线程已经终止运行</p><p>8.对象终结规则:一个对象的初始化完成先行发生于他的 finalize()方法的开始</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程学习与入门(1)</title>
      <link href="/2020/03/22/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%85%A5%E9%97%A8-1/"/>
      <url>/2020/03/22/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%85%A5%E9%97%A8-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>入门概念</p></blockquote><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>  同时拥有两个或者多个线程,如果程序在单核处理器上运行,多个线程将交替的换入或者换出内存,这些线程是同时存在的,每个线程都处于执行过程中的某个状态,如果运行在多核处理器上,此时,程序中的每个线程都分配到一个处理器核上,因此可以同时运行.</p><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>  高并发(High Concurrency)是互联网分布式架构设计中必须考虑的因素之一,通常是指通过设计保证系统能够同时并行处理很多请求.</p><h3 id="并发和高并发基本概念"><a href="#并发和高并发基本概念" class="headerlink" title="并发和高并发基本概念"></a>并发和高并发基本概念</h3><h4 id="并发-1"><a href="#并发-1" class="headerlink" title="并发"></a>并发</h4><p>  多个线程操作相同的资源,保证线程安全,合理使用资源.</p><h4 id="高并发-1"><a href="#高并发-1" class="headerlink" title="高并发"></a>高并发</h4><p>  服务能够同时处理很多请求,提高程序性能.</p><h3 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h3><pre><code>CPU的频率太快了,快到主存跟不上,这样在处理器时钟周期内,CPU常常需要等待主存,浪费资源.所以cache的出现,是为了缓解CPU和内存之间速度的不匹配问题.(结构:CPU-&gt;cache-&gt;memory)</code></pre><p><img src="/images/CPU_cache.jpg" alt></p><p>CPU cache意义:</p><pre><code>1:时间局部性,如果某个数据被访问,那么在不久的将来它很可能被再次访问;2.空间局部性,如果某个数据被访问,那么与它相邻的数据很快也可能被访问;</code></pre><p>CPU多级缓存的缓存一致性(MESI)</p><pre><code>用于保证多个CPU cache之间缓存共享数据的一致</code></pre><p>CPU多级缓存-乱序执行优化</p><pre><code>处理器为提高运算速度而做出违背代码原有顺序的优化.</code></pre><h3 id="JAVA内存模型-Java-Memory-Model-JMM"><a href="#JAVA内存模型-Java-Memory-Model-JMM" class="headerlink" title="JAVA内存模型(Java Memory Model,JMM)"></a>JAVA内存模型(Java Memory Model,JMM)</h3><h4 id="jvm内存架构"><a href="#jvm内存架构" class="headerlink" title="jvm内存架构"></a>jvm内存架构</h4><p><img src="/images/JMM.jpg" alt></p><h4 id="CPU物理内存架构"><a href="#CPU物理内存架构" class="headerlink" title="CPU物理内存架构"></a>CPU物理内存架构</h4><p><img src="/images/CPU_jiagou.jpg" alt></p><h4 id="java内存模型抽象结构图"><a href="#java内存模型抽象结构图" class="headerlink" title="java内存模型抽象结构图"></a>java内存模型抽象结构图</h4><p><img src="/images/JVM_chouxiang.jpg" alt></p><h4 id="java内存模型-同步八种操作"><a href="#java内存模型-同步八种操作" class="headerlink" title="java内存模型-同步八种操作"></a>java内存模型-同步八种操作</h4><h5 id="锁定-lock"><a href="#锁定-lock" class="headerlink" title="锁定(lock)"></a>锁定(lock)</h5><pre><code>作用于主内存的变量,把一个变量标识为一条线成独占状态</code></pre><h5 id="解锁-unlock"><a href="#解锁-unlock" class="headerlink" title="解锁(unlock)"></a>解锁(unlock)</h5><pre><code>作用于主内存的变量,把一个处于锁定状态的变量释放出来,释放后的变量才可以被其他线程锁定</code></pre><h5 id="读取-read"><a href="#读取-read" class="headerlink" title="读取(read)"></a>读取(read)</h5><pre><code>作用于主内存的变量,把一个变量值从主内存传输到线程的工作内存中,以便随后的load动作使用</code></pre><h5 id="载入-load"><a href="#载入-load" class="headerlink" title="载入(load)"></a>载入(load)</h5><pre><code>作用于主存的便令,它把read操作从主内存中得到的变量值放入到工作内存的变量副本中</code></pre><h5 id="使用-use"><a href="#使用-use" class="headerlink" title="使用(use)"></a>使用(use)</h5><pre><code>作用于工作内存的变量,把工作内存中的一个变量传递给执行引擎</code></pre><h5 id="赋值-assign"><a href="#赋值-assign" class="headerlink" title="赋值(assign)"></a>赋值(assign)</h5><pre><code>作用于工作内存的变量,它把一个从执行引擎接收到的值赋值给工作内存的变量</code></pre><h5 id="存储-store"><a href="#存储-store" class="headerlink" title="存储(store)"></a>存储(store)</h5><pre><code>作用于工作内存的变量,把工作内存中的一个变量的值传送到主内存中,以便随后的write操作</code></pre><h5 id="写入-write"><a href="#写入-write" class="headerlink" title="写入(write)"></a>写入(write)</h5><pre><code>作用于主内存的变量,它把store操作从工作内存中一个变量的值传送到主内存的变量中</code></pre><h4 id="java内存模型-同步规则"><a href="#java内存模型-同步规则" class="headerlink" title="java内存模型 - 同步规则"></a>java内存模型 - 同步规则</h4><p>1.如果要把一个变量从主内存中复制到工作内存.就需要按顺序的执行read和load操作,如果把变量从工作内存中同步回主内存中,就要按顺序的执行store和write操作.但java内存模型只要求上述操作必须按顺序执行,而没有保证必须是连续执行</p><p>2.不允许read和load,store和write操作之一单独出现</p><p>3.不允许一个线程丢弃它的最近assig的操作,即变量在工作内存中改变了之后必须同步到主内存中</p><p>4.不允许一个线程无原因的(没有发生过任何assign操作)把数据从工作内存同步到主内存中</p><p>5.一个新的变量只能在主内存中诞生,不允许在工作内存中直接使用一个未被初始化(load或assign)的变量.即就是对一个变量实施use和store操作之前,必须先执行过了assign和load操作</p><p>6.一个变量在同一时刻只允许一条线程对其lock操作,但lock操作可以被同一个线程重复执行多次,多次执行lock后,只有执行相同次数的unlock操作,变量才会被解锁.lock和unlock必须成对出现</p><p>7.如果对一个变量执行lock操作,将会清空工作内存中此变量的值,在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值.</p><p>8.如果一个变量事先没有被lock操作锁定,则不允许对它执行unlock操作,也不允许去unlock一个被其他线程锁定的变量</p><p>9.对一个变量执行unlock之前,必须先把变量同步到主内存中(执行store和write操作)</p><p><img src="/images/JVM_sync.jpg" alt></p><h3 id="并发的优势和风险"><a href="#并发的优势和风险" class="headerlink" title="并发的优势和风险"></a>并发的优势和风险</h3><p><img src="/images/bingfa_bijiao.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户不重复邀请码生成</title>
      <link href="/2020/03/17/%E7%94%A8%E6%88%B7%E4%B8%8D%E9%87%8D%E5%A4%8D%E9%82%80%E8%AF%B7%E7%A0%81%E7%94%9F%E6%88%90/"/>
      <url>/2020/03/17/%E7%94%A8%E6%88%B7%E4%B8%8D%E9%87%8D%E5%A4%8D%E9%82%80%E8%AF%B7%E7%A0%81%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  产生短长度的随机不重复唯一邀请码方式.搜集于网络,如侵权请留言删除</code></pre><h3 id="UUID-变种-产生-8-位字符串"><a href="#UUID-变种-产生-8-位字符串" class="headerlink" title="UUID 变种,产生 8 位字符串"></a>UUID 变种,产生 8 位字符串</h3><blockquote><p>短8位UUID思想其实借鉴微博短域名的生成方式，但是其重复概率过高，而且每次生成4个，需要随即选取一个,本算法利用62个可打印字符，通过随机生成32位UUID，由于UUID都为十六进制，所以将UUID分成8组，每4个为一组，然后通过模62操作，结果作为索引取出字符</p></blockquote><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] chars = <span class="keyword">new</span> String[] &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>,</span><br><span class="line">      <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>, <span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>, <span class="string">"m"</span>, <span class="string">"n"</span>, <span class="string">"o"</span>, <span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>,</span><br><span class="line">      <span class="string">"t"</span>, <span class="string">"u"</span>, <span class="string">"v"</span>, <span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>,</span><br><span class="line">      <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>,</span><br><span class="line">      <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>, <span class="string">"M"</span>, <span class="string">"N"</span>, <span class="string">"O"</span>, <span class="string">"P"</span>, <span class="string">"Q"</span>, <span class="string">"R"</span>, <span class="string">"S"</span>, <span class="string">"T"</span>, <span class="string">"U"</span>, <span class="string">"V"</span>,</span><br><span class="line">      <span class="string">"W"</span>, <span class="string">"X"</span>, <span class="string">"Y"</span>, <span class="string">"Z"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateShortUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuffer shortBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    String uuid = UUID.randomUUID().toString().replace(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        String str = uuid.substring(i * <span class="number">4</span>, i * <span class="number">4</span> + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> x = Integer.parseInt(str, <span class="number">16</span>);</span><br><span class="line">        shortBuffer.append(chars[x % <span class="number">0x3E</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shortBuffer.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="base-编码方式实现-产生-6-位邀请码的数据格式"><a href="#base-编码方式实现-产生-6-位邀请码的数据格式" class="headerlink" title="base 编码方式实现,产生 6 位邀请码的数据格式"></a>base 编码方式实现,产生 6 位邀请码的数据格式</h3><blockquote><p>6位邀请码：0-9十个数字，26个大写字母，在这其中再去除掉0和1，O和I防止它们两两混淆。总共获得了32个可用字符。那么能生成的邀请码总数为32的6次方，也就是1073741824个。10亿+个邀请码，在业务初期足够用户使用，如果随着业务的发展可对位数进行扩充。一般情况用户ID或用户编号都为长整型数且递增，那么现在我们将用户ID映射成一个6位的base32编码.</p></blockquote><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line">/\*\*</span><br><span class="line"></span><br><span class="line">- 邀请码生成器，基本原理：&lt;br/&gt;</span><br><span class="line">- <span class="number">1</span>）入参用户 ID：<span class="number">1</span> &lt;br/&gt;</span><br><span class="line">- <span class="number">2</span>）使用自定义进制转换之后为：V &lt;br/&gt;</span><br><span class="line">- <span class="number">3</span>）转换未字符串，并在后面添加<span class="string">'A'</span>：VA &lt;br/&gt;</span><br><span class="line">- <span class="number">4</span>）在 VA 后面再随机补足 <span class="number">4</span> 位，得到：VAHKHE &lt;br/&gt;</span><br><span class="line">- <span class="number">5</span>）反向转换时以<span class="string">'A'</span>为分界线，<span class="string">'A'</span>后面的不再解析 &lt;br/&gt;</span><br><span class="line">- \*/</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareCodeUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 自定义进制(0,1没有加入,容易与o,l混淆)，数组顺序可进行调整增加反推难度，A用来补位因此此数组不包含A，共31个字符。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] BASE = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'H'</span>, <span class="string">'V'</span>, <span class="string">'E'</span>, <span class="string">'8'</span>, <span class="string">'S'</span>, <span class="string">'2'</span>, <span class="string">'D'</span>, <span class="string">'Z'</span>, <span class="string">'X'</span>, <span class="string">'9'</span>, <span class="string">'C'</span>, <span class="string">'7'</span>, <span class="string">'P'</span>,</span><br><span class="line">       <span class="string">'5'</span>, <span class="string">'I'</span>, <span class="string">'K'</span>, <span class="string">'3'</span>, <span class="string">'M'</span>, <span class="string">'J'</span>, <span class="string">'U'</span>, <span class="string">'F'</span>, <span class="string">'R'</span>, <span class="string">'4'</span>, <span class="string">'W'</span>, <span class="string">'Y'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, <span class="string">'N'</span>, <span class="string">'6'</span>, <span class="string">'B'</span>, <span class="string">'G'</span>, <span class="string">'Q'</span>&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * A补位字符，不能与自定义重复</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> SUFFIX_CHAR = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 进制长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIN_LEN = BASE.length;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 生成邀请码最小长度</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CODE_LEN = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * ID转换为邀请码</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">idToCode</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[BIN_LEN];</span><br><span class="line">       <span class="keyword">int</span> charPos = BIN_LEN;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 当id除以数组长度结果大于0，则进行取模操作，并以取模的值作为数组的坐标获得对应的字符</span></span><br><span class="line">       <span class="keyword">while</span> (id / BIN_LEN &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">int</span> index = (<span class="keyword">int</span>) (id % BIN_LEN);</span><br><span class="line">       buf[--charPos] = BASE[index];</span><br><span class="line">       id /= BIN_LEN;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       buf[--charPos] = BASE[(<span class="keyword">int</span>) (id % BIN_LEN)];</span><br><span class="line">       <span class="comment">// 将字符数组转化为字符串</span></span><br><span class="line">       String result = <span class="keyword">new</span> String(buf, charPos, BIN_LEN - charPos);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 长度不足指定长度则随机补全</span></span><br><span class="line">       <span class="keyword">int</span> len = result.length();</span><br><span class="line">       <span class="keyword">if</span> (len &lt; CODE_LEN) &#123;</span><br><span class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       sb.append(SUFFIX_CHAR);</span><br><span class="line">       Random random = <span class="keyword">new</span> Random();</span><br><span class="line">       <span class="comment">// 去除SUFFIX_CHAR本身占位之后需要补齐的位数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CODE_LEN - len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">       sb.append(BASE[random.nextInt(BIN_LEN)]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       result += sb.toString();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 邀请码解析出ID&lt;br/&gt;</span></span><br><span class="line"><span class="comment">        * 基本操作思路恰好与idToCode反向操作。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">codeToId</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span>[] charArray = code.toCharArray();</span><br><span class="line">       <span class="keyword">long</span> result = <span class="number">0L</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BIN_LEN; j++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (charArray[i] == BASE[j]) &#123;</span><br><span class="line">       index = j;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (charArray[i] == SUFFIX_CHAR) &#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       result = result * BIN_LEN + index;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       result = index;</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String code = idToCode(<span class="number">1L</span>);</span><br><span class="line">       System.out.println(code);</span><br><span class="line">       System.out.println(codeToId(code));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-cli项目在Linux/macos下修改端口为80的问题</title>
      <link href="/2019/12/26/vue-cli%E9%A1%B9%E7%9B%AE%E5%9C%A8Linux-macos%E4%B8%8B%E4%BF%AE%E6%94%B9%E7%AB%AF%E5%8F%A3%E4%B8%BA80%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/12/26/vue-cli%E9%A1%B9%E7%9B%AE%E5%9C%A8Linux-macos%E4%B8%8B%E4%BF%AE%E6%94%B9%E7%AB%AF%E5%8F%A3%E4%B8%BA80%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:一直在写vue项目,但是最近需要将端口更改为80,在Linux/macos下无论是修改vue.config.js了面devServer的port为80还是在脚本命令后加启动参数--port 80,最后启动成功后的端口都是1024</code></pre><p>猜测:在Linux/macos下,端口范围是有一定的权限要求的.同事在Windows下直接修改为80是完全可以的.</p><p>此时,需要将npm命令用root的身份运行,才能有足够的权限来使用80端口.因为本机安装nodejs的时候,直接是安装到当前用户下的.使用sudo命令的时候,查找的命令目录是/usr/bin/,可以在该目录下建立对应的npm命令软链接,使root能够执行npm命令</p><pre><code>cd /usr/bin/  # 进入到目录which npm  # 查看当前npm安装路径sudo ln -s /opt/node-v10.16.3-linux-x64/bin/npm # 建立软链接sudo ln -s /opt/node-v10.16.3-linux-x64/bin/node  # 建立软链接sudo npm -v # 检测root下命令是否可用</code></pre><p>执行完毕后,使用sudo npm run serve即可正常在80端口下启动.</p>]]></content>
      
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用AES加密密钥大于128抛出Illegal key size or default parameters</title>
      <link href="/2019/12/26/%E4%BD%BF%E7%94%A8AES%E5%8A%A0%E5%AF%86%E5%AF%86%E9%92%A5%E5%A4%A7%E4%BA%8E128%E6%8A%9B%E5%87%BAIllegal-key-size-or-default-parameters/"/>
      <url>/2019/12/26/%E4%BD%BF%E7%94%A8AES%E5%8A%A0%E5%AF%86%E5%AF%86%E9%92%A5%E5%A4%A7%E4%BA%8E128%E6%8A%9B%E5%87%BAIllegal-key-size-or-default-parameters/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:使用AES加密时，当密钥大于128时，代码会抛出java.security.InvalidKeyException: Illegal key size or default parameters.</code></pre><p>刚入职公司后,第一次check运行项目的时候,连接配置中心的时候,密码使用了加密方式.抛出异常”java.lang.IllegalStateException: Cannot decrypt: key=spring.euraka.config.password….Caused by: java.security.InvalidKeyException: Illegal key size…”查阅相关资料后,得知Illegal key size or default parameters是指密钥长度是受限制的，java运行时环境读到的是受限的policy文件。文件位于${java_home}/jre/lib/security/.这种限制是因为美国对软件出口的控制。<br>解决办法：去掉这种限制需要下载Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files.</p><p>文件的下载链接可使用搜索引擎搜索JCE Unlimited download即可找到多个版本的链接地址,然后选择对应版本的即可.我当前机器的JDK版本是8,下载链接如下 <a href="https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html</a></p><p>下载完成后,解压.阅读里面的readme.txt文档.大致就是替换掉${java_home}/jre/lib/security/目录下的2个jar文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复习数据库设计相关知识</title>
      <link href="/2019/09/25/%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/09/25/%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库设计概念"><a href="#数据库设计概念" class="headerlink" title="数据库设计概念"></a>数据库设计概念</h3><p>  数据库设计就是根据业务系统的具体需要,结合自身选择的DBMS(数据库管理系统),为该业务系统设计出最优的数据存储模型.建立好数据库中表与表之间的关系过程,使之能对业务系统中的数据进行存储和高效访问.</p><h3 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h3><p>  将业务系统的需求转化为数据库的逻辑模型,通过ER图的方式对逻辑模型进行展示.</p><h4 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h4><p>  数据库表中的所有字段都是不可再分的单一属性,这个单一数据一般用基本的数据类型构成.比如,整形,浮点,字符串等.换句话说,第一范式的要求是数据库中所有的数据表都是二维表</p><p>  数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p><h4 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h4><p>  第二范式是在第一范式的基础之上建立的,数据库的表中不存在非关键字端对任意候选关键字段的部分 函数依赖(存在组合关键字中的某一关键字觉得非关键字的情况).</p><p>  第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。</p><p>  第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是属性完全依赖于主键。</p><h4 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h4><p>  第三范式是在第二范式的基础之上定义的,如果表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式.</p><p>  第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息.例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。 也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求</p><h4 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h4><p>  BC(Boyce.Codd)范式是在第三范式的基础之上,数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合BC范式.也就是说如果是复合关键字,则复合关键字之间也不能存在函数依赖关系.</p><h3 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h3><p>  选择合适的数据库管理系统,定义数据库/表/字段的命名规范,根据所选的数据库管理系统选择合适的字段类型,反范式设计</p><h4 id="选择合适的数据库管理系统"><a href="#选择合适的数据库管理系统" class="headerlink" title="选择合适的数据库管理系统"></a>选择合适的数据库管理系统</h4><p>  通常情况下,商业化应用大多采用Oracle,SQL Server,互联网应用及小型企业应用通常采用开源的MySQL和pgsql(另外也会跟所使用的编程语言有关,比如.net通常采用SQL Server;PHP和Java则通常采用MySQL等)</p><h4 id="选择合适的存储引擎-MySQL为例"><a href="#选择合适的存储引擎-MySQL为例" class="headerlink" title="选择合适的存储引擎(MySQL为例)"></a>选择合适的存储引擎(MySQL为例)</h4><p><img src="/images/mysql_engine.jpg" alt></p><h4 id="表和字段的命名规则"><a href="#表和字段的命名规则" class="headerlink" title="表和字段的命名规则"></a>表和字段的命名规则</h4><p>  1.可读性原则.使用大写和小写来格式化库对象名字以获取良好的可读性.(注:不同的数据库系统可能对大小写敏感区分的)</p><p>  2.表意性原则.对象的名字应该能够描述它所表示的对象.比如:表的名称应该能够体现出表中存储的数据内容;存储过程的名称则应该体现出其具体的功能</p><p>  3.长名原则.尽可能少使用或者不使用缩写</p><h4 id="表字段类型的选择原则"><a href="#表字段类型的选择原则" class="headerlink" title="表字段类型的选择原则"></a>表字段类型的选择原则</h4><p>  列的数据类型一方面影响数据存储空间的开销,也会影响数据的查询性能.当一个列可以选择多种数据类型时,应该优先考虑数字类型,其次是日期或者二进制类型,最后是字符串类型.对于相同级别的数据类型,应该优先选择占用空间小的数据类型.</p><p>  MySQL的数据类型和对应的存储空间如图:</p><p><img src="/images/mysql_field_type_size.jpg" alt></p><p>  一般的选择原则从2个角度考虑:</p><p>  1.在对数据进行比较(查询条件,JOIN条件及排序)操作时,同样的数据,字符处理往往比数字处理慢</p><p>  2.在数据库中,数据处理以页为单位,列的长度越小,利于性能提升</p><p>  3.char和varchar的选择:</p><pre><code>3.1 如果列中要存储的数据长度差不多一致,优先考虑char,否则varchar3.2 如果列中的最大数据长度小于50Byte,一般考虑char(如果该列很少用,则基于节省空间和I/O的考虑,也可以选择varchar)3.3 一般不定义大于50Byte的char类型列</code></pre><p>  4.decimal和float的选择:</p><pre><code>4.1 decimal用于存储精度数据,float只能用于存储非精度数据.4.2 由于float的存储空间开销一般比decimal小,所以非精度数据优先选择float类型</code></pre><p>  5.时间类型存储选择</p><pre><code>5.1 使用int存储.(优点:字段长度比datetime小.缺点:使用不方便,需要用函数进行转换.限制:只能存储到2038-01-19 11:04:07即2^32=2147483648的值)5.2 需要存储的时间粒度(年月日时分秒)</code></pre><p>  6.主键的选择</p><pre><code>6.1 区分业务主键和数据库主键.业务主键用于标示业务数据,进行表之间的关联;数据库主键为了优化数据存储(innodb会生成6个字节的隐含主键)6.2 根据数据库类型,考虑主键是否需要自增长(有些数据库是按主键的逻辑顺序存储的)6.3 主键的字段类型所占的空间要尽可能的小</code></pre><p>  7.避免使用外键约束</p><pre><code>7.1 使用外键会降低数据导入的效率,增加维护成本7.2 虽然不建议使用外键,但是相关联的列上一定要建立索引</code></pre><p>  8.避免使用触发器</p><pre><code>8.1 使用触发器会降低数据导入的效率8.2 使用触发器可能会出现数据异常8.3 使用触发器使业务变得更复杂</code></pre><p>  9.严禁使用预留字段</p><p>  10.反范式化设计</p><p>  反范式化是针对范式化而言的,有时候为了性能和读取效率的提升,要考虑适当的对第三范式进行违反,允许少量的数据冗余,使用空间来换取时间.</p><p>  反范式化优点和注意</p><pre><code>1. 减少表的关联数量2. 增加数据的读取效率3. 反范式化要适度使用,不能过度使用</code></pre><h3 id="数据库维护-如-MySQL"><a href="#数据库维护-如-MySQL" class="headerlink" title="数据库维护(如:MySQL)"></a>数据库维护(如:MySQL)</h3><h4 id="维护数据字典"><a href="#维护数据字典" class="headerlink" title="维护数据字典"></a>维护数据字典</h4><p>  使用第三方工具进行或者在建表的时候使用注释字段,然后再进行导出数据字典</p><h4 id="维护索引"><a href="#维护索引" class="headerlink" title="维护索引"></a>维护索引</h4><p>  选择合适的列建立索引,原则如下</p><pre><code>1. 出现在WHERE从句,GROUP BY从句,ORDER BY从句的列2. 可选择性高的列要放在索引的前面3. 索引中不要包括太长的数据类型</code></pre><p>  维护索引</p><pre><code>1. 索引不是越多越好,过多的索引会降低读写效率2. 定期维护索引碎片3. 在SQL语句中不要使用强制索引关键字</code></pre><h4 id="维护表结构"><a href="#维护表结构" class="headerlink" title="维护表结构"></a>维护表结构</h4><p>  1.使用线性变更表结构工具(MySQL5.5版本之前可采用pt-online-schema-change工具,5.6版本之后本身支持在线表结构更改)</p><p>  2.同时要对数据字典进行维护</p><p>  3.要控制表的宽度和大小</p><p>  4.数据库中通常适合的操作如下</p><pre><code>4.1 批量操作和逐条操作4.2 禁止使用select * 4.3 控制使用用户自定义函数4.4 不要使用数据库中的全文索引(使用专业的全文检索工具,如ES)</code></pre><p>  5.表的拆分</p><p>  1.为了控制表的宽度(字段的数量),可以进行表的垂直拆分,垂直拆分原则</p><pre><code>1.1.经常查询用到的列要放在一起1.2.text ,blob等大字段要拆分到附加表中</code></pre><p>  2.为了控制表的大小(行数),可以进行表的水平拆分,水平拆分主要对主键的控制.例如下图:</p><p><img src="/images/table_org_split.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx常用的location匹配规则</title>
      <link href="/2019/09/10/nginx%E5%B8%B8%E7%94%A8%E7%9A%84location%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
      <url>/2019/09/10/nginx%E5%B8%B8%E7%94%A8%E7%9A%84location%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录和整理一下nginx用到的匹配规则,部分内容搜集于网络上</p></blockquote><h3 id="Nginx的location语法"><a href="#Nginx的location语法" class="headerlink" title="Nginx的location语法"></a>Nginx的location语法</h3><p>location指令的作用是根据用户请求的URI来执行不同的应用，也就是根据用户请求的网站URL进行匹配，匹配成功即进行相关的操作</p><h4 id="nginx常见正则匹配符号表示"><a href="#nginx常见正则匹配符号表示" class="headerlink" title="nginx常见正则匹配符号表示"></a>nginx常见正则匹配符号表示</h4><pre><code>^ ： 匹配字符串的开始位置$ ：匹配字符串的结束位置.* : .匹配任意字符，*匹配数量0到正无穷\. : 斜杠用来转义,\.匹配.,特殊用法（值1|值2|值3|值4）：或匹配模式，例：（jpg|gif|png|bmp）匹配jpg或gif或png或bmpi : 不区分大小写</code></pre><h4 id="普通匹配"><a href="#普通匹配" class="headerlink" title="普通匹配"></a>普通匹配</h4><blockquote><p>location = URI { configuration } # 精确匹配,表示完全匹配规则才执行操作</p></blockquote><pre><code>例:  # http://{domain-name}/index  location = /index {    [configuration A]  }</code></pre><blockquote><p>location ^~ URI { configuration } # 非正则匹配，表示URI以某个常规字符串开头</p></blockquote><pre><code>例:  # URL为http://{domain_name}/images/xxx.jpg  location ^~ /images/ {    [ cofigurations D ]  }</code></pre><blockquote><p>location [space] URI { configuration} # 前缀匹配, 匹配后，继续更长前缀匹配和正则匹配</p></blockquote><pre><code>例:  # URL为http://{domain_name}/images/xxx.jpg  location /images/ {    # 字符匹配到 /images/，继续往下，会发现 ^~ 存在    [ cofigurations D ]  }</code></pre><h4 id="正则表达式匹配-表示执行正则匹配"><a href="#正则表达式匹配-表示执行正则匹配" class="headerlink" title="正则表达式匹配(~表示执行正则匹配)"></a>正则表达式匹配(~表示执行正则匹配)</h4><blockquote><p>location ~ URI { configuration } # 执行正则匹配，但区分大小写</p></blockquote><pre><code>例:  # http://{domain-name}/page/1匹配结尾数字为1~99时，配置生效  location ~ /page/\d{1,2} {      [ configuration B ]  }</code></pre><blockquote><p>location ~* URI { configuration } # 执行正则匹配，但不区分大小写</p></blockquote><pre><code>例:  # 匹配所有URL以.jpg、.jpeg、.gif结尾时,配置生效  location ~* /\.(jpg|jpeg|gif)$ {      [ configuration C ]  }</code></pre><blockquote><p>@符号,定义一个location，用于处理内部重定向</p></blockquote><pre><code>例:  location @error {      proxy_pass http://error;  }  error_page 404 @error;</code></pre><p>location的各个匹配之间的优先级顺序:</p><pre><code>(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</code></pre><h4 id="文件及目录匹配"><a href="#文件及目录匹配" class="headerlink" title="文件及目录匹配"></a>文件及目录匹配</h4><pre><code>*-f和!-f用来判断是否存在文件*-d和!-d用来判断是否存在目录*-e和!-e用来判断是否存在文件或目录*-x和!-x用来判断文件是否可执行</code></pre><h4 id="rewrite指令的最后一项参数为flag标记，flag标记有以下"><a href="#rewrite指令的最后一项参数为flag标记，flag标记有以下" class="headerlink" title="rewrite指令的最后一项参数为flag标记，flag标记有以下"></a>rewrite指令的最后一项参数为flag标记，flag标记有以下</h4><pre><code>last      相当于apache里面的[L]标记，表示rewritebreak     本条规则匹配完成后，终止匹配，不再匹配后面的规则redirect  返回302临时重定向，浏览器地址会显示跳转后的URL地址permanent 返回301永久重定向，浏览器地址会显示跳转后的URL地址</code></pre><h3 id="location指令配置示例"><a href="#location指令配置示例" class="headerlink" title="location指令配置示例"></a>location指令配置示例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">location  = / &#123;</span><br><span class="line">  # 精确匹配 / ，主机名后面不能带任何字符串</span><br><span class="line">  [ configuration A ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location  / &#123;</span><br><span class="line">  # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求</span><br><span class="line">  # 但是正则和最长字符串会优先匹配</span><br><span class="line">  [ configuration B ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /documents/ &#123;</span><br><span class="line">  # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索</span><br><span class="line">  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span><br><span class="line">  [ configuration C ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /documents/Abc &#123;</span><br><span class="line">  # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索</span><br><span class="line">  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span><br><span class="line">  [ configuration CC ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">  # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。</span><br><span class="line">  [ configuration D ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">  # 匹配所有以 gif,jpg或jpeg 结尾的请求</span><br><span class="line">  # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则</span><br><span class="line">  [ configuration E ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /images/ &#123;</span><br><span class="line">  # 字符匹配到 /images/，继续往下，会发现 ^~ 存在</span><br><span class="line">  [ configuration F ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /images/abc &#123;</span><br><span class="line">  # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在</span><br><span class="line">  # F与G的放置顺序是没有关系的</span><br><span class="line">  [ configuration G ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /images/abc/ &#123;</span><br><span class="line">  # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用</span><br><span class="line">    [ configuration H ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux使用systemd方式添加开机自动执行脚本</title>
      <link href="/2019/06/26/linux%E4%BD%BF%E7%94%A8systemd%E6%96%B9%E5%BC%8F%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
      <url>/2019/06/26/linux%E4%BD%BF%E7%94%A8systemd%E6%96%B9%E5%BC%8F%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前段时间在一台公网服务器上搭建了vpn服务用来映射内网一台gitlab服务器,实现跨网络也能进行代码提交等操作.过程中经过查找网络上的博客文档基本都没啥问题,但是后续使用过程中,发现客户端(pptp-linux)vpn连接会自动断开(大约是晚上的时候),后面写了一个脚本后台常驻,检测vpn是否连接,如果断开则自动重连.但是问题来了,如果服务器关机了然后开机,则不会自动去连接,需要手工执行连接的脚本.于是,查找相关的systemd方式实现开机启动执行相关脚本.由于内网服务器默认登录的账户不是root身份,所以使用其他小伙伴的建立/etc/rc.local文件的方式是未成功.以下是测试能够通过的方式(我的内网gitlab服务器是Ubuntu18.04.1-server版,理论上只要使用systemd的方式来管理系统服务启动的发行版都可以)</p></blockquote><h3 id="准备好要执行的脚本文件-auto-conn-sh"><a href="#准备好要执行的脚本文件-auto-conn-sh" class="headerlink" title="准备好要执行的脚本文件(auto_conn.sh)"></a>准备好要执行的脚本文件(auto_conn.sh)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">pppdNum=`ifconfig | grep ppp0 | wc -l`</span><br><span class="line"><span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">"pppdNum = <span class="variable">$pppdNum</span>"</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$pppdNum</span> -le 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">      <span class="comment"># </span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"vpn is down,waitting for connectting again..."</span></span><br><span class="line">      sleep 10</span><br><span class="line">      pppdNum_1=`ifconfig | grep ppp0 | wc -l`</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"pppdNum = <span class="variable">$pppdNum_1</span>"</span></span><br><span class="line">      <span class="comment">#</span></span><br><span class="line">      <span class="keyword">if</span> [ <span class="variable">$pppdNum_1</span> -ge 1 ]</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">"vpn has autolly connect success again!"</span></span><br><span class="line">          <span class="comment"># xxxxx是sudo执行的密码,每次连接后需要手工添加路由表,不然不能访问到服务器,ppp0是该网卡的名称.可通过ifconfig查看192.168.2.0/24是自己外网vpn服务器给内部电脑分配的内网ip网关前缀</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">'xxxxx'</span> | sudo -S route add -net 192.168.2.0/24 ppp0</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">"connectting.."</span></span><br><span class="line">          <span class="comment"># xxxxx是sudo执行的密码,vpn_name是自定义vpn连接的名称,000.000.000.000是vpn服务器的ip(公网ip),username是vpn登录的用户名,passwd是vpn登录的密码</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">'xxxxxx'</span> | sudo -S pptpsetup --create vpn_name --server 000.000.000.000 --username username --password passwd vpn-only --encrypt --start</span><br><span class="line">          <span class="built_in">echo</span> <span class="string">'c vpn_client'</span> &gt; /var/run/xl2tpd/l2tp-control</span><br><span class="line">              sleep 10</span><br><span class="line">          <span class="comment"># xxxxx是sudo执行的密码,每次连接后需要手工添加路由表,不然不能访问到服务器,ppp0是该网卡的名称.可通过ifconfig查看192.168.2.0/24是自己外网vpn服务器给内部电脑分配的内网ip网关前缀</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="string">'xxxxxx'</span> | sudo -S route add -net 192.168.2.0/24 ppp0</span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">sleep 5</span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><pre><code>注: 某条命令需要sudo执行的话,在脚本中可使用echo &apos;xxxxxx&apos; | sudo -S 的方式,xxxxxx就是对应的密码</code></pre><p>然后给脚本添加执行权限.sudo chmod +x</p><h3 id="创建一个service文件"><a href="#创建一个service文件" class="headerlink" title="创建一个service文件"></a>创建一个service文件</h3><p><code>sudo vim /etc/systemd/system/auto_startVPN.service</code></p><p>详细内容如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=自动连接vpn <span class="comment">#自定义的简介描述</span></span><br><span class="line">After=network-online.target.wants <span class="comment">#脚本所需要的前置service，可在/etc/systemd/system/下查看</span></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/home/xxx/xxx/auto_conn.sh <span class="comment">#第一步中的脚本文件路径</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>service文件一般正常的启动文件主要分成三部分</p><p>[Unit] 段: 启动顺序与依赖关系</p><p>[Service] 段: 启动行为,如何启动，启动类型</p><p>[Install] 段: 定义如何安装这个配置文件，即怎样做到开机启动</p><h3 id="使用systemctl命令使能这个服务开机启动"><a href="#使用systemctl命令使能这个服务开机启动" class="headerlink" title="使用systemctl命令使能这个服务开机启动"></a>使用systemctl命令使能这个服务开机启动</h3><p><code>sudo systemctl daemon-reload</code> //重新加载配置文件</p><p><code>sudo systemctl enable auto_startVPN.service</code> //设置开机启动刚刚新建的自动连接vpn的服务</p><p>重启电脑,等待个大约10多秒,执行ifconfig,会发现连接中会有ppp0这个网卡设备和对应的ip地址等信息,说明脚本执行成功也成功的自动连接上了vpn服务器.</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译安装nginx添加rtmp模块</title>
      <link href="/2019/06/01/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85nginx%E6%B7%BB%E5%8A%A0rtmp%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/06/01/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85nginx%E6%B7%BB%E5%8A%A0rtmp%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:nginx源码编译添加rtmp模块实现视频推流服务器环境:deepin linux 15.10.1(基于debian9)</code></pre><h3 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h3><p>执行命令前,最好执行一次sudo apt update更新下仓库</p><p><code>sudo apt install autoconf automake</code></p><p><code>sudo apt install libpcre3 libpcre3-dev</code></p><p><code>sudo apt install openssl</code></p><p><code>sudo apt install libssl-dev</code></p><h3 id="下载nginx和nginx-rtmp-module源码"><a href="#下载nginx和nginx-rtmp-module源码" class="headerlink" title="下载nginx和nginx-rtmp-module源码"></a>下载nginx和nginx-rtmp-module源码</h3><p>进入到一个目录(可以自己新建),然后clone nginx和rtmp模块的源码,地址可在github上面查找对应的仓库,然后进行clone操作(需要安装git)</p><p><code>git clone https://github.com/nginx/nginx.git --depth=1</code> // clone nginx源码,指定克隆深度depth为1即表示只克隆最近一次commit(clone时间大幅缩短)</p><p><code>git clone https://github.com/arut/nginx-rtmp-module.git --depth=1</code> // clone nginx-rtmp-module源码</p><p>进入到nginx源码目录,有一个auto文件夹，里面有一个名为configure的文件.通过命令参数调用该文件,生成MakeFile</p><p><code>cd nginx</code> // 进入到nginx源码目录</p><p><code>./auto/configure --prefix=/opt/nginx --with-http_ssl_module --with-http_v2_module --with-http_flv_module --with-http_mp4_module --add-module=../nginx-rtmp-module/</code></p><p><code>ls -al</code> // 查看当前目录(nginx)下的文件,会有一个产生的MakeFile文件</p><h3 id="编译和安装"><a href="#编译和安装" class="headerlink" title="编译和安装"></a>编译和安装</h3><p>当前目录还是位于上一步的nginx目录</p><p><code>make</code> // 编译</p><p><code>sudo make install</code> // 安装</p><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p><code>ls -l /opt/nginx/</code> // 查看opt目录下nginx目录的内容</p><p><code>sudo /opt/nginx/sbin/nginx</code> // 启动nginx服务,默认只能用root启动,所以加sudo</p><p><code>sudo chmod u+s /opt/nginx/sbin/nginx</code> // 为nginx文件加上setuid标志.(setuid只对文件有效).设置后可以通过普通用户就可以启动</p><ul><li><p>关于chmod扩展:如果是一个可执行文件, 那么在执行时, 一般该文件只拥有调用该文件的用户具有的权限. 而setuid, setgid 可以来改变这种设置:</p><p>setuid: 设置使文件在执行阶段具有文件所有者的权限</p><p>setgid: 该权限只对目录有效. 目录被设置该位后, 任何用户在此目录下创建的文件都具有和该目录所属的组相同的组.</p><p>sticky bit: 该位可以理解为防删除位. 一个文件是否可以被某用户删除, 主要取决于该文件所属的组是否对该用户具有写权限. 如果没有写权限, 则这个目录下的所有文件都不能被删除, 同时也不能添加新的文件. 如果希望用户能够添加文件但同时不能删除文件, 则可以对文件使用sticky bit位. 设置该位后, 就算用户对目录具有写权限, 也不能删除该文件,该权限只对目录有效.</p><p>具体使用如下</p><p>chmod u+s temp — 为temp文件加上setuid标志. (setuid 只对文件有效)</p><p>chmod g+s tempdir — 为tempdir目录加上setgid标志 (setgid 只对目录有效)</p><p>chmod o+t temp — 为temp文件加上sticky标志 (sticky只对文件有效) *</p></li></ul><p>浏览器打开localhost,正常就能打开nginx默认的首页面</p><h3 id="nginx-推流配置"><a href="#nginx-推流配置" class="headerlink" title="nginx 推流配置"></a>nginx 推流配置</h3><p><code>sudo vim /opt/nginx/conf/nginx.conf</code></p><pre><code>rtmp {  server {      listen 1935;      application rtmplive_demo {          live on;          max_connections 1024;      }      application hlsvideo {          live on;          hls on;          hls_path /home/bz/Desktop/video/hlsvideo; # 推流存放文件夹,自定义          hls_fragment 1s;      }  }}location ^~ /hlsvideo {  types {    application/vnd.apple.mpegurl    m3u8;    video/mp2t ts;  }  root /home/bz/Desktop/video; # 此处不能写/home/bz/Desktop/video/hlsvideo,因为路径中带了一层hlsvideo了,如果写上hlsvideo会导致读取m3u8文件404  add_header Cache-Control    no-cache;}</code></pre><p><code>sudo /opt/nginx/sbin/nginx -t</code> // 测试配置文件是否ok</p><p><code>sudo /opt/nginx/sbin/nginx -s reload</code></p><h4 id="测试rtmp推流"><a href="#测试rtmp推流" class="headerlink" title="测试rtmp推流"></a>测试rtmp推流</h4><p><code>ffmpeg -re -i ./龙珠超.布罗利.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp://192.168.100.31:1935/rtmplive_demo/longzhuchao</code></p><pre><code>注:rtmp://192.168.100.31:1935/rtmplive_demo/longzhuchao rtmp流地址,其中rtmplive_demo必须和nginx.conf中application中的rtmplive_demo名称必须一致,否则导致推流不成功</code></pre><p>打开VLC Media Player测试</p><p>在工具栏”媒体-&gt;打开网络串流”然后输入rtmp://192.168.100.31:1935/rtmplive_demo/longzhuchao点击确定即可进行直播预览转换后的rtmp视频流.效果如图</p><p><img src="/images/push_rtmp_res.png" alt></p><h4 id="测试HLS推流"><a href="#测试HLS推流" class="headerlink" title="测试HLS推流"></a>测试HLS推流</h4><p><code>ffmpeg -re -i ./龙珠超.布罗利.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp://192.168.100.31:1935/hlsvideo/longzhuchao</code></p><pre><code>注:rtmp://192.168.100.31:1935/hlsvideo/longzhuchao,其中hlsvideo必须和nginx.conf中application中hlsvideo名称必须一致,否则导致推流不成功</code></pre><p>打开VLC Media Player测试</p><p>HLS测试地址是http协议的.访问路径是nginx中http节点下server节点配置的.此处是<a href="http://192.168.100.31/hlsvideo/longzhuchao.m3u8" target="_blank" rel="noopener">http://192.168.100.31/hlsvideo/longzhuchao.m3u8</a></p><p>在工具栏”媒体-&gt;打开网络串流”然后输入<a href="http://192.168.100.31/hlsvideo/longzhuchao.m3u8点击确定即可进行直播预览转换后的rtmp视频流.效果如图" target="_blank" rel="noopener">http://192.168.100.31/hlsvideo/longzhuchao.m3u8点击确定即可进行直播预览转换后的rtmp视频流.效果如图</a></p><p><img src="/images/m3u8-res.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> rtmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx-rtmp-module-ffmpeg视频推流和rtsp转rtmp及hls</title>
      <link href="/2019/05/31/nginx-rtmp-module-ffmpeg%E8%A7%86%E9%A2%91%E6%8E%A8%E6%B5%81%E5%92%8Crtsp%E8%BD%ACrtmp%E5%8F%8Ahls/"/>
      <url>/2019/05/31/nginx-rtmp-module-ffmpeg%E8%A7%86%E9%A2%91%E6%8E%A8%E6%B5%81%E5%92%8Crtsp%E8%BD%ACrtmp%E5%8F%8Ahls/</url>
      
        <content type="html"><![CDATA[<h3 id="RTSP、RTMP、HTTP协议比较"><a href="#RTSP、RTMP、HTTP协议比较" class="headerlink" title="RTSP、RTMP、HTTP协议比较"></a>RTSP、RTMP、HTTP协议比较</h3><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><p>1.都是用在应用层的协议</p><p>2.理论上这三种协议都可以做直播和点播，但直播一般用RTSP和RTMP点播用HTTP</p><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>1.HTTP协议（HyperText Transfer Protocol，超文本传输协议)，是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准,HTTP是一个基于TCP/IP通信协议来传递数据(HTML 文件, 图片文件, 查询结果等).所以HTTP不是流媒体协议，RTMP和RTSP是流媒体协议</p><p>2.RTMP是Real Time Messaging Protocol（实时消息传输协议）的首字母缩写。该协议基于TCP，是一个协议族，包括RTMP基本协议及RTMPT/RTMPS/RTMPE等多种变种。RTMP是一种设计用来进行实时数据通信的网络协议，主要用来在Flash/AIR平台和支持RTMP协议的流媒体/交互服务器之间进行音视频和数据通信,RTMP一般传输flv,f4v格式流.</p><p>3.RTSP（Real Time Streaming Protocol），RFC2326，实时流传输协议.RTSP以客户端方式工作，对流媒体提供播放、暂停、后退、前进等操作.RTSP传输的一般是TS、MP4格式的流，其传输一般需要2~3个通道，命令和数据通道分离。使用RTSP协议传输流媒体数据需要有专门的媒体播放器和媒体服务器，也就是需要支持RTSP协议的客户端和服务器。</p><h3 id="ffmpeg简介"><a href="#ffmpeg简介" class="headerlink" title="ffmpeg简介"></a>ffmpeg简介</h3><p>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。它包括了目前领先的音/视频编码库libavcodec.可以轻易地实现多种视频格式之间的相互转换，例如可以将摄录下的视频avi等转成现在视频网站所采用的flv格式</p><h3 id="nginx-nginx-rtmp-moudle安装"><a href="#nginx-nginx-rtmp-moudle安装" class="headerlink" title="nginx+nginx-rtmp-moudle安装"></a>nginx+nginx-rtmp-moudle安装</h3><p>分别下载nginx和nginx-rtmp的源码然后进行编译即可.在此,为了方便我是直接使用的docker的tiangolo/nginx-rtmp镜像,docker安装参考上一篇初识docker文档</p><p><code>docker pull tiangolo/nginx-rtmp</code> // 拉取nginx-rtmp镜像</p><p><code>docker run -it --name nginx-rtmp tiangolo/nginx-rtmp -p 1935:1935</code> // 第一次运行容器,取个别名,后续可直接使用 <code>docker start nginx-rtmp</code></p><p>使用<code>netstat -tunlp | grep 1935</code> 检测1935端口是否正在监听,正常情况是正在监听中</p><h3 id="ffmpeg安装"><a href="#ffmpeg安装" class="headerlink" title="ffmpeg安装"></a>ffmpeg安装</h3><p><code>sudo apt install ffmpeg</code> // 安装ffmpeg(我当前环境deepin,仓库里面自带ffmpeg包)</p><p>其他操作系统需要去官网下载对应的安装包即可或者按照官方文档添加对应系统的ppa进行安装即可.</p><p>ffmpeg参数:</p><p>-re : 表示使用文件的原始帧率进行读取，因为ffmpeg读取视频帧的速度很快，如果不使用这个参数，ffmpeg可以在很短时间就把video.mp4中的视频帧全部读取完并进行推流，这样就无法体现出视频播放的效果了</p><p>-i :这个参数表示输入 ，后面跟的路劲文件就是输入文件。</p><p>-vcodec copy : -vcodec表示使用的视频编解码器 ，前缀v表示video。后面紧跟的copy 表示复制使用源文件的视频编解码器，比如原文件的编解码器(codec)是h264，则这里就使用h264</p><p>-acodec copy : -acodec表示使用的音频编解码器，前缀a表示audio。后面的copy 表示使用源文件的音频编解码器</p><p>-b:v 800k : -b:v表示视频的比特率(bitrate) ，为800k</p><p>-b:a 32k : 表示音频的比特率为32k</p><p>-f flv : -f表示format ，就是强制输出格式为flv，这一步其实也叫封装(mux)，封装要做的事就是把视频和音频混合在一起，进行同步。紧跟在后面的rtmp://xxx.xxx.xxx/xxx 表示输出的”文件名”，这个文件名可以是一个本地的文件，也可以指定为rtmp流媒体地址。指定为rtmp流媒体地址后，则ffmpeg就可以进行推流</p><h3 id="ffmpeg将rtsp转码为rtmp"><a href="#ffmpeg将rtsp转码为rtmp" class="headerlink" title="ffmpeg将rtsp转码为rtmp"></a>ffmpeg将rtsp转码为rtmp</h3><p>使用ffmpeg命令,将rtsp转码为rtmp.ffmpeg参数项很多,未对其深究,直接参考网友的命令的.-i后面是rtsp流地址.</p><p><code>ffmpeg -re -rtsp_transport tcp -i &quot;rtsp://184.72.239.149/vod/mp4://BigBuckBunny_175k.mov&quot; -f flv -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -r 10 -s 1280x720 -q 10 &quot;rtmp://127.0.0.1:1935/live/demo&quot;</code></p><pre><code>在执行转码命令过程中,可能会报信息类似 Past duration 0.999992 too large 的警告错误,经查询资料,是在-r参数后面指定的视频帧率参数导致的.rtsp://184.72.239.149/vod/mp4://BigBuckBunny_175k.mov这个地址是网络上的地址,可使用vlc media player查看源的帧率而设置</code></pre><h4 id="使用VLC-media-player测试播放转换后的rtmp地址"><a href="#使用VLC-media-player测试播放转换后的rtmp地址" class="headerlink" title="使用VLC media player测试播放转换后的rtmp地址"></a>使用VLC media player测试播放转换后的rtmp地址</h4><p>打开VLC media player播放器.在工具栏”媒体-&gt;打开网络串流”然后输入rtmp://127.0.0.1:1935/live/demo点击确定即可进行直播预览转换后的rtmp视频流</p><p><img src="/images/rtmp-result.png" alt></p><h3 id="ffmpeg将rtsp转码为hls"><a href="#ffmpeg将rtsp转码为hls" class="headerlink" title="ffmpeg将rtsp转码为hls"></a>ffmpeg将rtsp转码为hls</h3><p>使用ffmpeg命令,将rtsp转码为hls.ffmpeg参数项很多,未对其深究,直接参考网友的命令的.-i后面是rtsp流地址.</p><p><code>ffmpeg -f rtsp -rtsp_transport tcp -i rtsp://192.168.100.2/longzhu/demo_2 -r 23 -f hls -hls_time 4 -hls_list_size 5 -hls_wrap 10 /home/bz/Desktop/h5live/longzhuchao.m3u8</code></p><pre><code>在执行转码命令过程中,可能会报信息类似 Past duration 0.999992 too large 的警告错误,经查询资料,是在-r参数后面指定的视频帧率参数导致的.rtsp://184.72.239.149/vod/mp4://BigBuckBunny_175k.mov这个地址是网络上的地址,可使用vlc media player查看源的帧率而设置</code></pre><h4 id="使用VLC-media-player测试播放转换后的hls地址-m3u8文件"><a href="#使用VLC-media-player测试播放转换后的hls地址-m3u8文件" class="headerlink" title="使用VLC media player测试播放转换后的hls地址(m3u8文件)"></a>使用VLC media player测试播放转换后的hls地址(m3u8文件)</h4><p>打开VLC media player播放器.在工具栏”媒体-&gt;打开网络串流”然后输入<a href="http://192.168.100.31/hlsvideo/longzhuchao.m3u8点击确定即可进行直播预览转换后的rtmp视频流,该地址是在nginx中配置了的" target="_blank" rel="noopener">http://192.168.100.31/hlsvideo/longzhuchao.m3u8点击确定即可进行直播预览转换后的rtmp视频流,该地址是在nginx中配置了的</a></p><p><img src="/images/hls-result.png" alt></p><h3 id="ffmpeg推送视频文件到rtsp服务器"><a href="#ffmpeg推送视频文件到rtsp服务器" class="headerlink" title="ffmpeg推送视频文件到rtsp服务器"></a>ffmpeg推送视频文件到rtsp服务器</h3><p><code>ffmpeg -re -i ./龙珠超.布罗利.mp4 -vcodec copy -codec copy -f rtsp rtsp://192.168.252.1/longzhu/demo_2</code></p><pre><code>注:使用了easydarwin,rtsp://192.168.252.1地址就是启动easydarwin成功后的rtsp server地址</code></pre><h4 id="使用VLC-media-player测试播放推流后rtsp地址"><a href="#使用VLC-media-player测试播放推流后rtsp地址" class="headerlink" title="使用VLC media player测试播放推流后rtsp地址"></a>使用VLC media player测试播放推流后rtsp地址</h4><p><img src="/images/push_to_rtsp.png" alt></p><h3 id="ffmpeg推送视频文件到rtmp服务器"><a href="#ffmpeg推送视频文件到rtmp服务器" class="headerlink" title="ffmpeg推送视频文件到rtmp服务器"></a>ffmpeg推送视频文件到rtmp服务器</h3><p><code>ffmpeg -re -i ./龙珠超.布罗利.mp4 -vcodec copy -acodec copy -b:v 800k -b:a 32k -f flv rtmp://192.168.100.31:1935/rtmplive_demo/demo_3</code></p><pre><code>注:rtmp地址中的rtmplive_demo必须和nginx中配置的application名称一致才能推流成功,192.168.100.31是我的一台虚拟机</code></pre><h4 id="使用VLC-media-player测试播放推流后rtmp地址"><a href="#使用VLC-media-player测试播放推流后rtmp地址" class="headerlink" title="使用VLC media player测试播放推流后rtmp地址"></a>使用VLC media player测试播放推流后rtmp地址</h4><p><img src="/images/push_to_rtmp.png" alt></p><h3 id="ffmpeg转发rtsp流"><a href="#ffmpeg转发rtsp流" class="headerlink" title="ffmpeg转发rtsp流"></a>ffmpeg转发rtsp流</h3><p><code>ffmpeg -i rtsp://192.168.100.2:8554/longzhu/live -codec copy -f rtsp rtsp://192.168.252.1/longzhu/demo_1</code></p><pre><code>第一个rtsp是源地址,第二个是新地址.但是必须保证新地址是能够支持rtsp协议的才行.我试过使用nginx+rtsp是不能够成功的.所以换成了easydarwin,rtsp://192.168.252.1地址就是启动easydarwin成功后的rtsp server地址.</code></pre><p>效果图如下:</p><p><img src="/images/rtsp_to_rtsp.png" alt></p><p><strong>注:关于测试rtsp地址问题,上面的地址我测试的时候能够使用,但是不能保证以后能够一直正常使用,所以有网友图文讲解了使用VLC media player自制rtsp流.小伙伴的力量强大!其地址如下:<a href="https://blog.csdn.net/taoerit/article/details/51920018" target="_blank" rel="noopener">https://blog.csdn.net/taoerit/article/details/51920018</a><br>为了防止地址失效,我将页面截了一张完整图.图片如下:</strong></p><p><img src="/images/build_push_rtsp.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> rtmp </tag>
            
            <tag> rtsp </tag>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deepin linux下初识docker</title>
      <link href="/2019/05/29/deepin-linux%E4%B8%8B%E5%88%9D%E8%AF%86docker/"/>
      <url>/2019/05/29/deepin-linux%E4%B8%8B%E5%88%9D%E8%AF%86docker/</url>
      
        <content type="html"><![CDATA[<h3 id="deepin-linux-安装最新版-docker"><a href="#deepin-linux-安装最新版-docker" class="headerlink" title="deepin linux 安装最新版 docker"></a>deepin linux 安装最新版 docker</h3><p>可以参考官放 wiki 文档进行安装,地址如下:</p><p><a href="https://wiki.deepin.org/wiki/Docker#.E5.9C.A8_Deepin_.E4.B8.AD.E5.AE.89.E8.A3.85_Docker_.E6.9C.80.E6.96.B0.E7.89.88.E7.9A.84.E6.96.B9.E6.B3.95" target="_blank" rel="noopener">https://wiki.deepin.org/wiki/Docker#.E5.9C.A8_Deepin_.E4.B8.AD.E5.AE.89.E8.A3.85_Docker_.E6.9C.80.E6.96.B0.E7.89.88.E7.9A.84.E6.96.B9.E6.B3.95</a></p><p>但官网打开速度比较慢,另外关于最后一项禁止开启自启官方说的方式是无效的,笔者亲试至少在(deepin 15.10.1 基于 unstable 升级上来的)是无效的.所以将详情步骤记录如下:</p><pre><code>注:执行apt命令之前,最好先执行一次更新仓库操作sudo apt update</code></pre><p>1.如果以前安装过老版本，要确保先卸载以前版本.</p><p><code>sudo apt remove docker.io docker-engine</code></p><p>2.安装密钥管理与下载相关的工具</p><p>// 密钥管理（add-apt-repository ca-certificates 等）与下载（curl 等）相关的工具</p><p><code>sudo apt-get install apt-transport-https ca-certificates curl python-software-properties software-properties-common</code></p><p>3.下载并安装密钥</p><p><code>curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</code></p><p>执行成功后返回 OK 即可.如果不成功的话,可能是网络问题,我这儿是处于翻墙状态,所以是能成功的.不能成功的话,可以按照官方 wiki 上说的使用国内镜像源<code>curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -</code></p><p>4.查看密钥是否安装成功</p><p><code>sudo apt-get fingerprint 0EBFCD88</code></p><p>如果成功会提示</p><p><code>pub 4096R/0EBFCD88 2017-02-22 Key fingerprint = 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code><br><code>uid Docker Release (CE deb) &lt;docker@docker.com&gt;</code><br><code>sub 4096R/F273FCD8 2017-02-22</code></p><p>5.在 source.list 中添加 docker-ce 软件源</p><pre><code>在此需要注意当前系统版本,执行 cat /etc/debian_version查看当前系统是基于debian的哪个版本.debian版本号和系统代号如下:</code></pre><table><thead><tr><th>系统代号</th><th>版本号</th></tr></thead><tbody><tr><td>squeeze</td><td>6.x</td></tr><tr><td>wheezy</td><td>7.x</td></tr><tr><td>jessie</td><td>8.x</td></tr><tr><td>stretch</td><td>9.x</td></tr></tbody></table><p>deepin 15.10.x 是基于 debian9.0 的,所以加入源如下:</p><p>sudo vim /etc/apt/sources.list</p><p><code>deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian stretch stable</code></p><p>6.更新仓库</p><p><code>sudo apt update</code></p><p>7.安装 docker-ce</p><p><code>sudo apt install docker-ce</code></p><pre><code>注:这一步网络不好可能会导致失败,多试几次总会成功的.</code></pre><p>8.启动 docker</p><p><code>sudo systemctl start docker</code> 或者<br><code>service docker start</code></p><p>9.查看安装的版本信息</p><p><code>docker version</code></p><p>10.验证 docker 是否被正确安装并且能够正常使用</p><p><code>sudo docker run hello-world</code></p><p>如果能够正常下载，并能够正常执行，则说明 docker 正常安装</p><p>11.让普通用户也能运行 docker</p><pre><code>默认情况下，普通用户运行 docker 会有权限问题，每次运行都得加 sudo，很麻烦。把你的账号加到 docker 用户组后就不用加 sudo 了：</code></pre><p><code>sudo usermod -aG docker test</code> // test 是用户名,替换为自己的,执行后注销登录</p><p>12.docker service 默认是开机自启的,强迫症取消开机自启的</p><pre><code>这一点,官方说的安装chkconfig来管理</code></pre><p>安装 chkconfig</p><p><code>sudo apt install chkconfig</code></p><p>移除自启</p><p><code>sudo chkconfig --del docker</code></p><pre><code>但是试了,重启无效无效.需要通过systemctl命令来禁止</code></pre><p><code>sudo systemctl disable docker</code></p><h3 id="docker-使用初识"><a href="#docker-使用初识" class="headerlink" title="docker 使用初识"></a>docker 使用初识</h3><h4 id="docker-入门命令"><a href="#docker-入门命令" class="headerlink" title="docker 入门命令"></a>docker 入门命令</h4><p>docker 安装后,默认是没有任何镜像的,如果安装后执行了 docker run hello-world 的话,是有一个 hello-world 的镜像的.</p><p><code>docker images</code> // 查看本地的镜像</p><p>可以通过 pull 命令获取相关镜像</p><p><code>docker search nginx</code> // 在 docker.io 上搜索 nginx 相关的镜像</p><p><code>docker pull nginx:latest</code> // latest 代表取最新版本,要获取其他版本 docker pull nginx:xxxx</p><p><code>docker run -itd --name nginx1.0 nginx</code> // -d: 后台启动容器;-i: 以交互模式运行容器，通常与 -t 同时使用;-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用; –name：容器的别名，默认为随机的,这儿为 nginx1.0</p><pre><code>第一次使用run运行指定别名后,以后可通过docker start+ 别名的方式启动</code></pre><p><code>docker ps</code> // 查看正在运行的容器</p><p><code>docker ps -a</code> // 查看所有容器</p><p><code>docker ps -l</code> // 查看最近一次运行的容器</p><p><code>docker exec -it nginx1.0 bash</code> // 进入 nginx1.0 容器的命令行</p><p><code>docker start nginx1.0</code> // 启动 nginx1.0 容器</p><p><code>docker stop nginx1.0</code> // 停止 nginx1.0 容器</p><p><code>docker rm nginx1.0</code> // 删除 nginx1.0 容器</p><h5 id="docker常用清除相关缓存命令"><a href="#docker常用清除相关缓存命令" class="headerlink" title="docker常用清除相关缓存命令"></a>docker常用清除相关缓存命令</h5><p><code>docker image prune</code> // 清除悬空镜像（没有标签的镜像，通常是构建过程中的中间层）</p><p><code>docker image prune -a</code> // 清除所有未使用的镜像</p><p><code>docker network prune</code> // 清除未使用的网络</p><p><code>docker volume prune</code> // 清除未使用的卷</p><p><code>docker container prune</code> // 清除所有停止的容器</p><p><code>docker builder prune</code> // 清除所有未使用的构建缓存</p><h4 id="docker-网络"><a href="#docker-网络" class="headerlink" title="docker 网络"></a>docker 网络</h4><p>linux 使用 namespace 来进行资源的隔离 ，docker 的隔离性</p><p>1.docker 的网路类型分为：</p><p>Bridge 模式：桥接（默认的模式）</p><p>host 模式：容器将不会获得独立的 network namespace，将和主机公用一个；即在 docker 中使用网络和主机上一样的；</p><p>None：不与外界任何东西进行通讯</p><p>2.采用 Bridge 的时候需要和主机通讯，就需要使用端口映射</p><p>docker run -d –name nginx1.0 -p 8080:80 nginx # 主机的 8080 端口映射到容器中的 80 端口</p><pre><code>多个端口映射可以跟多个-p,比如:-p 8080:80 -p 6379:6379</code></pre><h4 id="docker-镜像备份和导入镜像"><a href="#docker-镜像备份和导入镜像" class="headerlink" title="docker 镜像备份和导入镜像"></a>docker 镜像备份和导入镜像</h4><p><code>docker save -o /home/xxx/images/nginx.tar nginx1.0</code> // 将 nginx1.0 镜像备份到/home/xxx/images/目录下</p><p><code>docker load --input /home/xxx/images/nginx.tar</code> // 导入镜像</p><h4 id="docker挂载物理机本地目录"><a href="#docker挂载物理机本地目录" class="headerlink" title="docker挂载物理机本地目录"></a>docker挂载物理机本地目录</h4><p>docker可以支持把一个宿主机上的目录挂载到镜像里。</p><p><code>docker run -itd -v /home/bz/Downloads:/home/Downloads nginx1.0</code> // 通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径</p><p>默认挂载的路径权限为读写。如果指定为只读可以用：ro</p><p><code>docker run -itd -v /home/bz/Downloads:/home/Downloads:ro nginx1.0</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pdfbox解析PDF文件</title>
      <link href="/2019/05/14/pdfbox%E8%A7%A3%E6%9E%90PDF%E6%96%87%E4%BB%B6/"/>
      <url>/2019/05/14/pdfbox%E8%A7%A3%E6%9E%90PDF%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  最近需要使用到对PDF文件内容进行解析,然后对文件的部分内容进行索引查询.在解析的PDF的时候Java语言有2个  开源的PDF工具:PDFbox和Itext.</code></pre><p>PDFbox和Itext都能读取、解析pdf文件，并且可对文件进行修改.有小伙伴将2个工具对比总结出以下结论:<br><strong>在读取和解析PDF的时候使用PDFBox，较为简单，示例较为详细;修改PDF的时候使用Itext，支持粒度较细，比如控制文字字体等</strong></p><h3 id="Itext"><a href="#Itext" class="headerlink" title="Itext"></a>Itext</h3><p>  iText是著名的开放项目，是用于生成PDF文档的一个java类库。通过iText不仅可以生成PDF或rtf的文档，而且可以将XML、Html文件转化为PDF文件等.目前只是用到对PDF文档的解析,所以对于Itext具体使用暂未查看,</p><pre><code>官网:https://itextpdf.com/插入文字可以自定义字体，使用字库文件(ttf)</code></pre><h3 id="PDFBox"><a href="#PDFBox" class="headerlink" title="PDFBox"></a>PDFBox</h3><h4 id="引入PDFBox工具库jar"><a href="#引入PDFBox工具库jar" class="headerlink" title="引入PDFBox工具库jar"></a>引入PDFBox工具库jar</h4><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt;    &lt;artifactId&gt;pdfbox&lt;/artifactId&gt;    &lt;version&gt;2.0.15&lt;/version&gt; &lt;!--当前使用2.0.15的版本--&gt;&lt;/dependency&gt;</code></pre><h4 id="编写PDFUtils类"><a href="#编写PDFUtils类" class="headerlink" title="编写PDFUtils类"></a>编写PDFUtils类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.pdfbox.cos.COSName;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.io.RandomAccessBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.pdfparser.PDFParser;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.pdmodel.PDDocument;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.pdmodel.PDPage;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.text.PDFTextStripper;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pdf文档解析工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> bz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(PDFUtils<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pdfPath pdf文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PDDocument <span class="title">initPDDocument</span><span class="params">(String pdfPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File pdfFile = Paths.get(pdfPath).toFile();</span><br><span class="line">        <span class="keyword">if</span> (!pdfFile.exists()) &#123;</span><br><span class="line">            logger.error(<span class="string">"pdf文件不存在"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新建一个PDF解析器对象</span></span><br><span class="line">        PDFParser pdfParser = <span class="keyword">new</span> PDFParser(<span class="keyword">new</span> RandomAccessBuffer(<span class="keyword">new</span> FileInputStream(pdfFile)));</span><br><span class="line">        <span class="comment">// 对PDF文件进行解析</span></span><br><span class="line">        pdfParser.parse();</span><br><span class="line">        <span class="comment">// 获取解析后得到的PDF文档对象</span></span><br><span class="line">        PDDocument pdfdocument = pdfParser.getPDDocument();</span><br><span class="line">        <span class="keyword">return</span> pdfdocument;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream 输入流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PDDocument <span class="title">initPDDocument</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个PDF解析器对象</span></span><br><span class="line">        PDFParser pdfParser = <span class="keyword">new</span> PDFParser(<span class="keyword">new</span> RandomAccessBuffer(inputStream));</span><br><span class="line">        <span class="comment">// 对PDF文件进行解析</span></span><br><span class="line">        pdfParser.parse();</span><br><span class="line">        <span class="comment">// 获取解析后得到的PDF文档对象</span></span><br><span class="line">        PDDocument pdfdocument = pdfParser.getPDDocument();</span><br><span class="line">        <span class="keyword">return</span> pdfdocument;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析pdf文档中的字符内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pdDocument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startPage  开始页码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endPage    结束页码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getContent</span><span class="params">(PDDocument pdDocument, <span class="keyword">int</span> startPage, <span class="keyword">int</span> endPage)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (endPage &lt;= startPage) &#123;</span><br><span class="line">            logger.error(<span class="string">"页码参数不正确"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新建一个PDF文本剥离器</span></span><br><span class="line">        PDFTextStripper stripper = <span class="keyword">new</span> PDFTextStripper();</span><br><span class="line">        stripper.setStartPage(startPage); <span class="comment">// 开始提取页数</span></span><br><span class="line">        stripper.setEndPage(endPage); <span class="comment">// 结束提取页数</span></span><br><span class="line">        <span class="comment">// 从PDF文档对象中剥离文本</span></span><br><span class="line">        String result = stripper.getText(pdDocument);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析pdf文档中的所有图片列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pdDocument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startPage  开始页码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endPage    结束页码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;PDImageXObject&gt; <span class="title">getImageList</span><span class="params">(PDDocument pdDocument, <span class="keyword">int</span> startPage, <span class="keyword">int</span> endPage)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (endPage &lt;= startPage) &#123;</span><br><span class="line">            logger.error(<span class="string">"页码参数不正确"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;PDImageXObject&gt; imageList = <span class="keyword">new</span> ArrayList&lt;PDImageXObject&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startPage; i &lt; endPage; i++) &#123;</span><br><span class="line">            PDPage page = pdDocument.getPage(i);</span><br><span class="line">            Iterable&lt;COSName&gt; objectNames = page.getResources().getXObjectNames();</span><br><span class="line">            <span class="keyword">for</span> (COSName imageObjectName : objectNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (page.getResources().isImageXObject(imageObjectName)) &#123;</span><br><span class="line">                    PDImageXObject imageXObject = (PDImageXObject) page.getResources()</span><br><span class="line">                            .getXObject(imageObjectName);</span><br><span class="line">                    imageList.add(imageXObject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> imageList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用PDFUtils类方法"><a href="#调用PDFUtils类方法" class="headerlink" title="调用PDFUtils类方法"></a>调用PDFUtils类方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PDDocument pdDocument = PDFUtils.initPDDocument(<span class="string">"/home/bz/Desktop/1.pdf"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pdDocument != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取文档文本内容</span></span><br><span class="line">        String result = PDFUtils.getContent(pdDocument, <span class="number">0</span>, pdDocument.getNumberOfPages());</span><br><span class="line">        System.out.println(<span class="string">"PDF文件的文本内容如下："</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="comment">// 获取文档中的所有图片</span></span><br><span class="line">        List&lt;PDImageXObject&gt; imageList = PDFUtils.getImageList(pdDocument, <span class="number">0</span>,pdDocument.getNumberOfPages());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imageList.size(); i++) &#123;</span><br><span class="line">            PDImageXObject imageXObject = imageList.get(i);</span><br><span class="line">            BufferedImage bufferedImage = imageXObject.getImage();</span><br><span class="line">            ImageIO.write(bufferedImage, imageXObject.getSuffix(),</span><br><span class="line">                    <span class="keyword">new</span> FileOutputStream(Paths</span><br><span class="line">                            .get(<span class="string">"/home/bz/Desktop/"</span> + i + <span class="string">"."</span> + imageXObject.getSuffix()).toFile()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> pdfbox </tag>
            
            <tag> pdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中utf8和utf8mb4区别对emoji支持</title>
      <link href="/2019/04/27/MySQL%E4%B8%ADutf8%E5%92%8Cutf8mb4%E5%8C%BA%E5%88%AB%E5%AF%B9emoji%E6%94%AF%E6%8C%81/"/>
      <url>/2019/04/27/MySQL%E4%B8%ADutf8%E5%92%8Cutf8mb4%E5%8C%BA%E5%88%AB%E5%AF%B9emoji%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容  四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。  当然，为了节省空间，一般情况下使用utf8也就够了.  查看当前的MySQL版本:  mysql&gt; select version();  或者  mysql --version</code></pre><h3 id="utf8不支持emoji表情的问题"><a href="#utf8不支持emoji表情的问题" class="headerlink" title="utf8不支持emoji表情的问题"></a>utf8不支持emoji表情的问题</h3><p>  当使用utf8字符集的时候,插入emoji表情符号会提示” Incorrect string value: ‘\xXX\xXX\xXX\xXX’ for column……”,原因在于MySQL中utf8字符集只支持三字节UTF-8编码的Unicode范围，而emoji字符属于四字节编码部分.此时,需要将库表的字符集更改为utf8mb4</p><h3 id="修改字符集为utf8mb4"><a href="#修改字符集为utf8mb4" class="headerlink" title="修改字符集为utf8mb4"></a>修改字符集为utf8mb4</h3><p>  修改/etc/mysql/my.cnf文件或者/etc/mysql/mysql.conf.d/mysqld.cnf文件,修改以下参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server = utf8mb4</span><br><span class="line">collation-server = utf8mb4_unicode_ci</span><br><span class="line">init_connect = &apos;SET NAMES utf8mb4&apos;</span><br><span class="line">character-set-client-handshake = false</span><br></pre></td></tr></table></figure><pre><code>注:1.init_connect=&apos;SET NAMES utf8mb4&apos; 表示初始化连接都设置为utf8mb4字符集;2.skip-character-set-client-handshake = true 忽略客户端字符集设置，不论客户端是何种字符集，都按照init_connect中的设置进行使用</code></pre><h3 id="对数据库相关的表进行字符集修改"><a href="#对数据库相关的表进行字符集修改" class="headerlink" title="对数据库相关的表进行字符集修改"></a>对数据库相关的表进行字符集修改</h3><h4 id="建立新库和表的情况-直接使用utf8mb4字符"><a href="#建立新库和表的情况-直接使用utf8mb4字符" class="headerlink" title="建立新库和表的情况,直接使用utf8mb4字符"></a>建立新库和表的情况,直接使用utf8mb4字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS test default charset utf8mb4 COLLATE utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `t_table`  (</span><br><span class="line">  `id` varchar(36) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,</span><br><span class="line">  `create_time` datetime(0) NULL DEFAULT NULL,</span><br><span class="line">  &apos;comment&apos; varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;</span><br></pre></td></tr></table></figure><h4 id="已经存在表的情况-对库-表和字段都修改为utf8mb4"><a href="#已经存在表的情况-对库-表和字段都修改为utf8mb4" class="headerlink" title="已经存在表的情况,对库,表和字段都修改为utf8mb4"></a>已经存在表的情况,对库,表和字段都修改为utf8mb4</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER DATABASE test CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line">mysql&gt;ALTER TABLE `t_table` CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line">mysql&gt;ALTER TABLE `t_table` MODIFY COLUMN `comment`  varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><h3 id="重启MySQL服务"><a href="#重启MySQL服务" class="headerlink" title="重启MySQL服务"></a>重启MySQL服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/mysqld restart 或者service mysql restart</span><br></pre></td></tr></table></figure><h3 id="登录数据库查看字符集是否更改成功"><a href="#登录数据库查看字符集是否更改成功" class="headerlink" title="登录数据库查看字符集是否更改成功"></a>登录数据库查看字符集是否更改成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES WHERE Variable_name LIKE &apos;character%&apos; OR Variable_name LIKE &apos;collation%&apos;;</span><br><span class="line"></span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | utf8mb4                    |</span><br><span class="line">| character_set_connection | utf8mb4                    |</span><br><span class="line">| character_set_database   | utf8mb4                    |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | utf8mb4                    |</span><br><span class="line">| character_set_server     | utf8mb4                    |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">| collation_connection     | utf8mb4_unicode_ci         |</span><br><span class="line">| collation_database       | utf8mb4_unicode_ci         |</span><br><span class="line">| collation_server         | utf8mb4_unicode_ci         |</span><br><span class="line">+--------------------------+----------------------------+</span><br></pre></td></tr></table></figure><pre><code>关于Windows下MySQL的一点坑:之前一个旧式的服务器采用的是Windows server2012,mysql使用的是安装版的.安装路径在C:\Program Files\MySQL\MySQL Server 5.6下.有个my-default.ini配置文件,但是无论对这个文件如何配置修改,重启服务器都无效.经过多方搜索,发现Windows下MySQL服务默认使用的不是该文件,而是采用C:\ProgramData\MySQL\MySQL Server 5.6下的my.ini这个文件.所以需要对这个文件修改才能使其生效.</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx限制某个IP同一时间段的访问次数</title>
      <link href="/2019/04/22/nginx%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AAIP%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E6%AE%B5%E7%9A%84%E8%AE%BF%E9%97%AE%E6%AC%A1%E6%95%B0/"/>
      <url>/2019/04/22/nginx%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AAIP%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E6%AE%B5%E7%9A%84%E8%AE%BF%E9%97%AE%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>  摘要:</p><pre><code>nginx可以通过HttpLimitReqModul和HttpLimitZoneModule配置来限制ip在同一时间段的访问次数来防cc攻击HttpLimitReqModul用来限制连单位时间内连接数的模块，使用limit_req_zone和limit_req指令配合使用来达到限制。一旦并发连接超过指定数量，就会返回503错误。HttpLimitConnModul用来限制单个ip的并发连接数，使用limit_zone和limit_conn指令注:两个模块的区别前一个是对一段时间内的连接数限制，后者是对同一时刻的连接数限制</code></pre><h3 id="HttpLimitReqModul-限制某一段时间内同一ip访问数实例"><a href="#HttpLimitReqModul-限制某一段时间内同一ip访问数实例" class="headerlink" title="HttpLimitReqModul 限制某一段时间内同一ip访问数实例"></a>HttpLimitReqModul 限制某一段时间内同一ip访问数实例</h3><p>在http作用域下配置limit_req_zone指令,如下:<br>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    http&#123;</span><br><span class="line">      ...</span><br><span class="line">      #定义一个名为allips的limit_req_zone用来存储session，大小是10M内存，</span><br><span class="line">      #以$binary_remote_addr 为key,限制平均每秒的请求为20个，</span><br><span class="line">      #1M能存储16000个状态，rete的值必须为整数，</span><br><span class="line">      #如果限制两秒钟一个请求，可以设置成30r/m</span><br><span class="line">      limit_req_zone $binary_remote_addr zone=allips:10m rate=20r/s;</span><br><span class="line">      ...</span><br><span class="line">      server&#123;</span><br><span class="line">          ...</span><br><span class="line">          location &#123;</span><br><span class="line">              ...</span><br><span class="line">  </span><br><span class="line">              #限制每ip每秒不超过20个请求，漏桶数burst为5</span><br><span class="line">              #brust的意思就是，如果第1秒、2,3,4秒请求为19个，</span><br><span class="line">              #第5秒的请求为25个是被允许的。</span><br><span class="line">              #但是如果你第1秒就25个请求，第2秒超过20的请求返回503错误。</span><br><span class="line">              #nodelay，如果不设置该选项，严格使用平均速率限制请求数，</span><br><span class="line">              #第1秒25个请求时，5个请求放到第2秒执行，</span><br><span class="line">              #设置nodelay，25个请求将在第1秒执行。</span><br><span class="line">  </span><br><span class="line">              limit_req zone=allips burst=5 nodelay;</span><br><span class="line">              ...</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="HttpLimitZoneModule-限制并发连接数实例"><a href="#HttpLimitZoneModule-限制并发连接数实例" class="headerlink" title="HttpLimitZoneModule 限制并发连接数实例"></a>HttpLimitZoneModule 限制并发连接数实例</h3><p>在http作用域下配置limit_zone指令,limit_zone只能定义在http作用域，limit_conn可以定义在http server location作用域.如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  http&#123;</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    #定义一个名为one的limit_zone,大小10M内存来存储session，</span><br><span class="line">    #以$binary_remote_addr 为key</span><br><span class="line">    #nginx 1.18以后用limit_conn_zone替换了limit_conn</span><br><span class="line">    #且只能放在http作用域</span><br><span class="line">    limit_conn_zone   one  $binary_remote_addr  10m; </span><br><span class="line">    ...</span><br><span class="line">    server&#123;</span><br><span class="line">        ...</span><br><span class="line">        location &#123;</span><br><span class="line">            ...</span><br><span class="line">           limit_conn one 20;          #连接数限制</span><br><span class="line"> </span><br><span class="line">           #带宽限制,对单个连接限数，如果一个ip两个连接，就是500x2k</span><br><span class="line">           limit_rate 500k;           </span><br><span class="line"> </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nginx白名单设置"><a href="#nginx白名单设置" class="headerlink" title="nginx白名单设置"></a>nginx白名单设置</h3><p>上面默认配置对多有的ip都有限制,有些时候我们不希望对搜索引擎的蜘蛛或者自己测试ip进行限制，<br>对于特定的白名单ip我们可以借助geo指令实现,如下:</p><pre><code>geo指令定义了一个白名单$limited变量，默认值为1，如果客户端ip在上面的范围内，$limited的值为0</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">   geo $limited&#123;</span><br><span class="line">      default 1;</span><br><span class="line">      #google</span><br><span class="line">      64.233.160.0/19 0;</span><br><span class="line">      65.52.0.0/14 0;</span><br><span class="line">      66.102.0.0/20 0;</span><br><span class="line">      66.249.64.0/19 0;</span><br><span class="line">      72.14.192.0/18 0;</span><br><span class="line">      74.125.0.0/16 0;</span><br><span class="line">      209.85.128.0/17 0;</span><br><span class="line">      216.239.32.0/19 0;</span><br><span class="line">      #M$</span><br><span class="line">      64.4.0.0/18 0;</span><br><span class="line">      157.60.0.0/16 0;</span><br><span class="line">      157.54.0.0/15 0;</span><br><span class="line">      157.56.0.0/14 0;</span><br><span class="line">      207.46.0.0/16 0;</span><br><span class="line">      207.68.192.0/20 0;</span><br><span class="line">      207.68.128.0/18 0;</span><br><span class="line">      #yahoo</span><br><span class="line">      8.12.144.0/24 0;</span><br><span class="line">      66.196.64.0/18 0;</span><br><span class="line">      66.228.160.0/19 0;</span><br><span class="line">      67.195.0.0/16 0;</span><br><span class="line">      74.6.0.0/16 0;</span><br><span class="line">      68.142.192.0/18 0;</span><br><span class="line">      72.30.0.0/16 0;</span><br><span class="line">      209.191.64.0/18 0;</span><br><span class="line">      #My IPs</span><br><span class="line">      127.0.0.1/32 0;</span><br><span class="line">      123.456.0.0/28 0; #example for your server CIDR</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用的使用总结</title>
      <link href="/2019/03/16/git%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2019/03/16/git%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目</code></pre><h3 id="对一个已存在的远程仓库进行clone和提交代码操作"><a href="#对一个已存在的远程仓库进行clone和提交代码操作" class="headerlink" title="对一个已存在的远程仓库进行clone和提交代码操作"></a>对一个已存在的远程仓库进行clone和提交代码操作</h3><p>clone代码</p><blockquote><p>$ git clone [-b branchName] 远程地址 [filefolder name]</p></blockquote><blockquote><p>-b代表clone某个分支,后面跟分支的名称.代码clone到本地后,当前路径会多一个与git 远程项目名相同的文件夹(手工指定文件夹名除外).</p></blockquote><blockquote><p>$ cd 文件夹名</p></blockquote><p>提交代码:</p><blockquote><p>$ git status // 查看当前工作目录的状态</p></blockquote><blockquote><p>$ git add . 或 git add -u 或 git add -A(git add –all的缩写) //添加要提交的文件到git暂存区. 相关区别:三条命令对应的git版本不一样也有区别.</p></blockquote><blockquote><p>git1.x 版本<img src="/images/git1.x.jpg" alt></p></blockquote><blockquote><p>git2.x 版本<img src="/images/git2.x.jpg" alt></p></blockquote><blockquote><p>使用2.x以上版本的git使用-a和.是一样的.本人通常使用.更加方便快捷</p></blockquote><blockquote><p>$ git status // 添加文件到暂存区后再次查看确保文件的状态</p></blockquote><blockquote><p>$ git commit -m “注释”</p></blockquote><blockquote><p>$ git remote -v // 查看当前已经存在的git 远程url</p></blockquote><blockquote><p>$ git push -u 远程名称 本地要提交的分支:远程分支 // 远程分支不存在的时候会自动在远程创建该名称分支</p></blockquote><h3 id="已有代码在用户本地-远程不存在的情况"><a href="#已有代码在用户本地-远程不存在的情况" class="headerlink" title="已有代码在用户本地,远程不存在的情况"></a>已有代码在用户本地,远程不存在的情况</h3><blockquote><p>$ cd existing_folder</p></blockquote><blockquote><p>$ git init</p></blockquote><blockquote><p>$ git status</p></blockquote><blockquote><p>$ git remote add origin <a href="mailto:git@code.aliyun.com" target="_blank" rel="noopener">git@code.aliyun.com</a>:baz/foo.git</p></blockquote><blockquote><p>$ git add .</p></blockquote><blockquote><p>$ git status</p></blockquote><blockquote><p>$ git commit -m “注释”</p></blockquote><blockquote><p>$ git push -u origin master:master // 提交本地master到远程master</p></blockquote><h3 id="对远程初始化仓库有git-history-本地代码也有git-history的情况"><a href="#对远程初始化仓库有git-history-本地代码也有git-history的情况" class="headerlink" title="对远程初始化仓库有git history,本地代码也有git history的情况"></a>对远程初始化仓库有git history,本地代码也有git history的情况</h3><blockquote><p>针对远程本地都有git 提交的情况,比较特殊.比如阿里云code上面新建项目必须选择对应的模板,会进行对仓库初始化操作.而本地存在之前的项目(已经含有git记录,比如gitlab,coding之类的).推荐方式:先从远程clone下来.然后删除clone下来的文件夹下的文件(.git目录除外).然后commit-&gt;push提交到远程</p></blockquote><p>1.删除远程仓库不需要的文件</p><blockquote><p>$ git clone alicodeurl xxx</p></blockquote><blockquote><p>$ cd xxx</p></blockquote><blockquote><p>//去资源文件管理器中手动删除除.git目录外的其他文件. linux/osx也可cd 目录再rm删除</p></blockquote><blockquote><p>$ git status</p></blockquote><blockquote><p>$ git add .</p></blockquote><blockquote><p>$ git status</p></blockquote><blockquote><p>$ git commit -m “注释”</p></blockquote><blockquote><p>$ git push -u origin master:master // 提交本地master到远程master</p></blockquote><p>2.对本地项目进行提交到远程</p><blockquote><p>$ cd project filefolder</p></blockquote><blockquote><p>$ git remote add origin <a href="mailto:git@code.aliyun.com" target="_blank" rel="noopener">git@code.aliyun.com</a>:baz/foo.git</p></blockquote><blockquote><p>$ git pull origin master –allow-unrelated-histories // 会弹出merge的编辑器,删除或者增加内容后退出</p></blockquote><blockquote><p>$ git add .</p></blockquote><blockquote><p>$ git commit -m “注释”</p></blockquote><blockquote><p>$ git push -u origin master:master // 提交本地master到远程master</p></blockquote><h3 id="项目开发中的分支使用"><a href="#项目开发中的分支使用" class="headerlink" title="项目开发中的分支使用"></a>项目开发中的分支使用</h3><p>切换分支</p><blockquote><p>$ git checkout 分支名称</p></blockquote><p>创建分支dev</p><blockquote><p>$ git checkout -b dev  // 创建并进入到分支,git branch 可查看当前分支指针状态</p></blockquote><h4 id="注"><a href="#注" class="headerlink" title="注"></a>注</h4><p>约定在Dev分支上面进行编码开发.上述的所有提交代码命令必须在dev分支上执行,最后的一句git push 换成以下命令</p><blockquote><p>$ git push -u origin dev:dev // 提交本地dev到远程dev.第一次远程无dev会自动创建dev</p></blockquote><p>更新远程分支代码到本地:</p><blockquote><p>$ git fetch origin dev // fetch远程dev分支代码 ..避免使用pull</p></blockquote><p>在当前分支合并fetch下面的代码</p><blockquote><p>$ git merge origin/dev  // 合并从远程dev分支fetch下来的代码</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>版本正式上线后,需要将dev分支发布到Master分支.采用以下命令:</p><blockquote><p>$ git checkout master  // 切换到Master分支</p></blockquote><blockquote><p>$ git merge –no-ff dev // 对Dev分支进行合并</p></blockquote><blockquote><p>使用–no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，推荐采用这种做法</p></blockquote><h3 id="Git4个阶段的撤销操作"><a href="#Git4个阶段的撤销操作" class="headerlink" title="Git4个阶段的撤销操作"></a>Git4个阶段的撤销操作</h3><blockquote><p>了解git阶段首选理解git的几个区:</p></blockquote><blockquote><p>工作区(working area),</p></blockquote><blockquote><p>暂存区(stage),</p></blockquote><blockquote><p>本地仓库(local repository),</p></blockquote><blockquote><p>远程仓库(remote repository).</p></blockquote><blockquote><p>每将文件存到不同的区的时候会产生一个状态,在加上最开始的一个状态总共5个状态.</p></blockquote><blockquote><p>未修改(Origin)</p></blockquote><blockquote><p>已修改(Modified)</p></blockquote><blockquote><p>已暂存(Staged)</p></blockquote><blockquote><p>已提交(Committed)</p></blockquote><blockquote><p>已推送(Pushed)</p></blockquote><h5 id="1-文件处于已修改的状态-即修改过文件-未暂存-add"><a href="#1-文件处于已修改的状态-即修改过文件-未暂存-add" class="headerlink" title="1.文件处于已修改的状态,即修改过文件.未暂存(add)"></a>1.文件处于已修改的状态,即修改过文件.未暂存(add)</h5><blockquote><p>文件已修改,恢复到初始状态(未做任何修改状态)</p></blockquote><blockquote><p>$git checkout . 或者 $git reset –hard origin/dev    // 恢复到与远程dev保持一致的状态,相当于刚clone dev的状态</p></blockquote><h5 id="2-文件处于已暂存-stage-未提交-commit"><a href="#2-文件处于已暂存-stage-未提交-commit" class="headerlink" title="2.文件处于已暂存(stage),未提交(commit)"></a>2.文件处于已暂存(stage),未提交(commit)</h5><blockquote><p>文件已经进行过git add . 操作,但是还未进行git commit操作</p></blockquote><blockquote><p>$git reset  // 恢复到已修改的状态</p></blockquote><blockquote><p>$git checkout . // 继续执行这条,就恢复到初始状态(未做任何修改状态)</p></blockquote><blockquote><p>如果要实现恢复到初始状态(未做任何修改状态),除了通过执行上面2步命令外,也可一直接执行下面这句,一步恢复到初始状态</p></blockquote><blockquote><p>$git reset –hard // 一步到初始状态</p></blockquote><h5 id="3-文件处于已提交-commit-未推送-push"><a href="#3-文件处于已提交-commit-未推送-push" class="headerlink" title="3.文件处于已提交(commit),未推送(push)"></a>3.文件处于已提交(commit),未推送(push)</h5><blockquote><p>这种情况下,代表已经提交到本地仓库了,既然已经污染了你的本地仓库，那么就从远程仓库把代码取回来吧.恢复到初始状态了,</p></blockquote><blockquote><p>$git reset –hard origin/dev  //<b>直接恢复到初始化状态,但已做的修改全部会丢失</b></p></blockquote><h5 id="4-文件处于已推送-push"><a href="#4-文件处于已推送-push" class="headerlink" title="4.文件处于已推送(push)"></a>4.文件处于已推送(push)</h5><blockquote><p>既git add了，又git commit了，并且还git push了，这时代码已经进入远程仓库。如果想恢复的话.由于本地仓库和远程仓库是等价的，只需要先恢复本地仓库，再强制push到远程仓库就好了</p></blockquote><blockquote><p>$git reset –hard HEAD^   //将本地恢复到初始状态,<b>之前已做的修改全部会丢失</b></p></blockquote><blockquote><p>$git push -f // 将本地仓库初始化后推送到远程,将远程保持和本地一致</p></blockquote><h5 id="注-只要还未影响到本地仓库-local-repository-的时候-即没有commit时-都可以恢复到已修改的状态-一旦commit后-影响了本地仓库-就只能恢复到上一次的本地仓库的版本-所做的修改都会丢失"><a href="#注-只要还未影响到本地仓库-local-repository-的时候-即没有commit时-都可以恢复到已修改的状态-一旦commit后-影响了本地仓库-就只能恢复到上一次的本地仓库的版本-所做的修改都会丢失" class="headerlink" title="注:只要还未影响到本地仓库(local repository)的时候,即没有commit时,都可以恢复到已修改的状态.一旦commit后,影响了本地仓库,就只能恢复到上一次的本地仓库的版本.所做的修改都会丢失.."></a>注:只要还未影响到本地仓库(local repository)的时候,即没有commit时,都可以恢复到已修改的状态.一旦commit后,影响了本地仓库,就只能恢复到上一次的本地仓库的版本.所做的修改都会丢失..</h5><p>###git撤销暂存区的文件</p><blockquote><p>有时候执行git add . 后,将当前目录下的所有改动文件都添加到了暂存区,此时如果有三两个文件是不需要添加进暂存区的,可以执行以下命令将文件从暂存区移除<br>$git rm –cached 文件名</p></blockquote><h3 id="git-tag的常用使用"><a href="#git-tag的常用使用" class="headerlink" title="git tag的常用使用"></a>git tag的常用使用</h3><blockquote><p>Git可以对某个版本打上标签(tag)，表示本版本为发行版</p></blockquote><blockquote><p>$git tag // 查看所有标签</p></blockquote><blockquote><p>$git tag -l 1.0.*  // 打印符合检索条件的标签</p></blockquote><blockquote><p>$git checkout 1.0.0 // 查看对应标签状态</p></blockquote><blockquote><p>$git tag -a 1.0.0 -m “1.0.0版本” // 创建带备注标签(推荐)</p></blockquote><blockquote><p>$git tag -a 1.0.0 0c3b62d -m “备注信息” // 针对特定commit版本SHA创建标签</p></blockquote><blockquote><p>$git tag -d 1.0.0 // 删除本地1.0.0标签</p></blockquote><blockquote><p>$git push origin –tags // 将本地所有标签发布到远程仓库</p></blockquote><blockquote><p>$git push origin 1.0.0 // 指定标签版本(1.0.0)发送</p></blockquote><blockquote><p>$git push origin –delete 1.0.0 // 删除远程仓库对应标签,此命令需要Git版本 &gt; V1.7.0</p></blockquote><blockquote><p>$git push origin :refs/tags/1.0.0 // 删除远程仓库对应标签,此命令需要Git版本 &lt; V1.7.0</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat解决java.lang.IllegalArgumentException: Invalid character异常</title>
      <link href="/2019/02/21/tomcat%E8%A7%A3%E5%86%B3java-lang-IllegalArgumentException-Invalid-character%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/02/21/tomcat%E8%A7%A3%E5%86%B3java-lang-IllegalArgumentException-Invalid-character%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>tomcat新版添加了对于http头的验证。出现java.lang.IllegalArgumentException: Invalid character found in the request target. The valid char… 异常</p></blockquote><p>网上查找了几种方法归类</p><p>1.更换tomcat版本,但是7,8,9的版本都更换过,问题依然.但是有网友确实可以解决,但是更换到具体什么版本未知.</p><p>2.前端http请求的时候对参数进行URL编码处理,理论上是绝对可行的,但是已有的http请求数很多,一个一个修改工作量大.未试</p><p>3.配置tomcat的catalina.properties 添加或者修改： tomcat.util.http.parser.HttpParser.requestTargetAllow=|{}</p><p>4.使用Connector中relaxedPathChars和relaxedQueryChars属性可以解决问题.找到tomcat/conf/server.xml,在Connector中增加这两个配置.<br><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;    relaxedPathChars=&quot;[]{}|\^&quot; relaxedQueryChars=&quot;[]{}|\^&quot; /&gt;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于vue组件实现web端页面调用摄像头拍照</title>
      <link href="/2019/01/17/%E5%9F%BA%E4%BA%8Evue%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0web%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E6%8B%8D%E7%85%A7/"/>
      <url>/2019/01/17/%E5%9F%BA%E4%BA%8Evue%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0web%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E6%8B%8D%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  基于vue组件化方式实现PC web端页面调用摄像头拍照功能,测试是在chrome浏览器的环境下.</code></pre><p>1.封装TakePhoto 组件,组件里面暴露出始化摄像头,拍照并且返回拍照后图片的base64码的方法</p><p>TakePhoto 组件的全部代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;video</span><br><span class="line">      ref=&quot;video&quot;</span><br><span class="line">      :width=&quot;width&quot;</span><br><span class="line">      :height=&quot;height&quot;</span><br><span class="line">      autoplay</span><br><span class="line">      style=&quot;width= 100%; height=100%; object-fit: fill&quot;</span><br><span class="line">    &gt;&lt;/video&gt;</span><br><span class="line">    &lt;canvas ref=&quot;canvas&quot; width=&quot;300&quot; height=&quot;400&quot; v-show=&quot;taked&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;TakePhoto&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    width: &#123;</span><br><span class="line">      default: 300 // 不传默认300</span><br><span class="line">    &#125;,</span><br><span class="line">    height: &#123;</span><br><span class="line">      default: 400 // 不传默认400</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      video: null,</span><br><span class="line">      track: &apos;&apos;,</span><br><span class="line">      taked: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    init(call) &#123;</span><br><span class="line">      this.taked = false</span><br><span class="line">      this.video = this.$refs.video</span><br><span class="line">      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia</span><br><span class="line">      if (navigator.getUserMedia) &#123;</span><br><span class="line">        navigator.getUserMedia(&#123; video: true &#125;,</span><br><span class="line">          (stream) =&gt; &#123;</span><br><span class="line">            this.track = stream.getTracks()[0]  // 通过这个关闭摄像头</span><br><span class="line">            try &#123;</span><br><span class="line">              this.video.src = window.URL.createObjectURL(stream) // chrome版本&lt;=70</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">              this.video.srcObject = stream // chrome版本&gt;70</span><br><span class="line">            &#125;</span><br><span class="line">            this.video.onloadedmetadata = (e) =&gt; &#123;</span><br><span class="line">              console.log(e)</span><br><span class="line">              this.video.play()</span><br><span class="line">              call(true)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, (err) =&gt; &#123;</span><br><span class="line">            console.log(err)</span><br><span class="line">            call(false)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        call(false)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    takePhoto(call) &#123;</span><br><span class="line">      let canvas = this.$refs.canvas</span><br><span class="line">      let context2D = canvas.getContext(&apos;2d&apos;)</span><br><span class="line">      context2D.fillStyle = &apos;#ffffff&apos;</span><br><span class="line">      context2D.fillRect(0, 0, this.width, this.height)</span><br><span class="line">      context2D.drawImage(this.video, 0, 0, this.width, this.height)</span><br><span class="line">      let image_code = canvas.toDataURL(&apos;image/png&apos;)//图片的base64</span><br><span class="line">      this.taked = true</span><br><span class="line">      call(true, image_code)</span><br><span class="line">      if (null != this.track) &#123;</span><br><span class="line">        this.track.stop()//关闭摄像头</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    if (null != this.track) &#123;</span><br><span class="line">      this.track.stop()//关闭摄像头</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">canvas &#123;</span><br><span class="line">position: absolute;</span><br><span class="line">left: 0;</span><br><span class="line">top: 0;</span><br><span class="line">z-index: 1000;</span><br><span class="line">&#125;</span><br><span class="line">.wrapper &#123;</span><br><span class="line">position: relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><pre><code>说明: 摄像区域的宽高由外部传入,不传采用默认的值.init()初始化摄像头,takePhoto()进行拍照操作</code></pre><p>2.调用TakePhoto组件里面的方法进行拍照</p><p>调用TakePhoto 组件的关键代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;TakePhoto class=&quot;photo&quot; ref=&quot;photo&quot;&gt;&lt;/TakePhoto&gt;</span><br><span class="line">  &lt;div class=&quot;takePhoto-btn&quot; @click=&quot;handleTakePhoto&quot; &#123;&#123;statusMsg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">handleTakePhoto() &#123;</span><br><span class="line">  if (this.status === 1) &#123; // 初始化摄像头</span><br><span class="line">    this.statusMsg = &apos;查找设备中...&apos;</span><br><span class="line">    this.$refs.photo.init((res) =&gt; &#123;</span><br><span class="line">      if (res) &#123;</span><br><span class="line">        this.status = 2</span><br><span class="line">        this.statusMsg = &apos;拍照&apos;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        alert(&apos;未发现设备&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;) // 初始化摄像头</span><br><span class="line">  &#125; else if (this.status === 2) &#123; // 拍照</span><br><span class="line">    this.$refs.photo.takePhoto((res, img) =&gt; &#123;</span><br><span class="line">      if (res) &#123;</span><br><span class="line">        this.status = 3</span><br><span class="line">        console.log(img)</span><br><span class="line">        this.statusMsg = &apos;重新拍&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else if (this.status === 3) &#123; // 重新拍</span><br><span class="line">    this.$refs.photo.init((res) =&gt; &#123;</span><br><span class="line">      if (res) &#123;</span><br><span class="line">        this.status = 2</span><br><span class="line">        this.statusMsg = &apos;拍照&apos;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        alert(&apos;未发现设备&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;) // 初始化摄像头</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>说明:组件中定义statusMsg和status两个变量,statusMsg主要是改变整个流程中状态信息的提示,status是对应的状态码.</code></pre><p>3.实际效果图</p><p><img src="/images/photo.gif" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode配置前端vue开发环境</title>
      <link href="/2018/12/13/vscode%E9%85%8D%E7%BD%AE%E5%89%8D%E7%AB%AFvue%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/12/13/vscode%E9%85%8D%E7%BD%AE%E5%89%8D%E7%AB%AFvue%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  使用vscode配置前端vue开发环境</code></pre><p>1.安装好vscode后,安装常用的几个插件</p><pre><code>Auto Close Tag : 自动闭合标签插件Beautify : 格式化js,json,css,sass,html等文件ESLint : 使用eslint规范对代码进行处理file-icons : 文件图标,便利区分不同类型的文件Monokai Theme : 一款类似sublime text主流的主题设置,使界面美观,享受美好的编码心情Path Intellisense : 自动提示文件路径插件Prettier : 因为vscode默认的格式化是不能通过eslint校验规范的,需要改为此插件Vetur : vscode的vue工具插件HTML CSS Support : 在标签中class属性的时候,提示class的名称px2rem : 将像素值转为rem插件下面是markdown相关的插件Markdown-TOC : 对markdown文档生成目录的插件,有2个,请选择作者为AlanWalk的</code></pre><p>2.安装好上述插件后,对其进行配置设置(2018-12-15更 v.1.30.0)</p><pre><code>在文件-&gt;首选项-&gt;设置-&gt;用户设置里面写入以下配置</code></pre>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"workbench.startupEditor"</span>: <span class="string">"newUntitledFile"</span>,</span><br><span class="line">    <span class="attr">"window.title"</span>: <span class="string">"$&#123;dirty&#125;$&#123;activeEditorLong&#125;$&#123;separator&#125;$&#123;rootName&#125;$&#123;separator&#125;$&#123;appName&#125;"</span>,</span><br><span class="line">    <span class="attr">"extensions.ignoreRecommendations"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"workbench.iconTheme"</span>: <span class="string">"file-icons"</span>,</span><br><span class="line">    <span class="attr">"workbench.colorTheme"</span>: <span class="string">"Monokai"</span>,</span><br><span class="line">    <span class="attr">"vetur.format.defaultFormatter.js"</span>: <span class="string">"vscode-typescript"</span>,</span><br><span class="line">    <span class="attr">"extensions.autoUpdate"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"update.channel"</span>: <span class="string">"none"</span>,</span><br><span class="line">    <span class="attr">"eslint.autoFixOnSave"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"files.autoSave"</span>: <span class="string">"off"</span>,</span><br><span class="line">    <span class="attr">"eslint.validate"</span>: [</span><br><span class="line">        <span class="string">"javascript"</span>,</span><br><span class="line">        <span class="string">"javascriptreact"</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"language"</span>: <span class="string">"vue"</span>,</span><br><span class="line">            <span class="attr">"autoFix"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"language"</span>: <span class="string">"html"</span>,</span><br><span class="line">            <span class="attr">"autoFix"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"vue"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"eslint.options"</span>: &#123;</span><br><span class="line">        <span class="attr">"plugins"</span>: [</span><br><span class="line">            <span class="string">"html"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"editor.tabSize"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"prettier.eslintIntegration"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"vetur.format.defaultFormatterOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"html"</span>: <span class="string">"prettier"</span>,</span><br><span class="line">        <span class="attr">"css"</span>: <span class="string">"prettier"</span>,</span><br><span class="line">        <span class="attr">"postcss"</span>: <span class="string">"prettier"</span>,</span><br><span class="line">        <span class="attr">"scss"</span>: <span class="string">"prettier"</span>,</span><br><span class="line">        <span class="attr">"less"</span>: <span class="string">"prettier"</span>,</span><br><span class="line">        <span class="attr">"js"</span>: <span class="string">"prettier"</span>,</span><br><span class="line">        <span class="attr">"ts"</span>: <span class="string">"prettier"</span>,</span><br><span class="line">        <span class="attr">"stylus"</span>: <span class="string">"stylus-supremacy"</span>,</span><br><span class="line">        <span class="attr">"wrap_attributes"</span>: <span class="string">"force-aligned"</span>,</span><br><span class="line">        <span class="attr">"prettier"</span>: &#123;</span><br><span class="line">            <span class="attr">"semi"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"singleQuote"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"eslint.alwaysShowStatus"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"window.titleBarStyle"</span>: <span class="string">"custom"</span>,</span><br><span class="line">    <span class="attr">"files.eol"</span>: <span class="string">"\n"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.vscode 1.29版本以上markdown-toc生成目录默认是有问题的,1.29版本以下能够直接正常使用</p><pre><code>1.29版本以上,请在file-&gt;preferences-&gt;setting-&gt;text editor中找到Eol配置的地方,设置为\n即可.详细情况见 https://github.com/AlanWalk/markdown-toc/issues/65</code></pre><p>4.vscode 1.30版本在file-&gt;preferences-&gt;setting下找不到打开setting.json文件的入口了.如下图,可以在系统路径下找到该文件编辑即可.</p><pre><code>文件路径Windows: %APPDATA%\Code\User\settings.jsonmacOS: $HOME/Library/Application Support/Code/User/settings.jsonLinux: $HOME/.config/Code/User/settings.json</code></pre><p><img src="/images/vscode.1.30.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axis2调用webservice</title>
      <link href="/2018/12/11/axis2%E8%B0%83%E7%94%A8webservice/"/>
      <url>/2018/12/11/axis2%E8%B0%83%E7%94%A8webservice/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#webservice一种跨编程语言和跨操作系统平台的远程调用技术">WebService:一种跨编程语言和跨操作系统平台的远程调用技术.</a></li><li><a href="#webservice的实现包有很多java语言有jdk16后内置的jwsapache-cxfapache-axisapache-axis2">WebService的实现包有很多,Java语言有jdk1.6后内置的jws.*,Apache cxf,Apache Axis,Apache Axis2.</a><ul><li><a href="#1远程调用">1.远程调用</a><ul><li><a href="#11-axis2wsdl地址方式调用">1.1 axis2+wsdl地址方式调用:</a></li><li><a href="#12-axis2endpoint地址方式调用">1.2 axis2+endpoint地址方式调用:</a></li></ul></li><li><a href="#2wsdl2java方式调用">2.wsdl2java方式调用</a></li></ul></li></ul><!-- /TOC --><h3 id="WebService-一种跨编程语言和跨操作系统平台的远程调用技术"><a href="#WebService-一种跨编程语言和跨操作系统平台的远程调用技术" class="headerlink" title="WebService:一种跨编程语言和跨操作系统平台的远程调用技术."></a>WebService:一种跨编程语言和跨操作系统平台的远程调用技术.</h3><pre><code>WebService都是基于http请求(POST请求,无GET请求)XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术。XML+XSD：WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务对象的返回结果是什么）。XML是WebService平台中表示数据的格式。SOAP(Simple Object Access Protocol)：简单对象访问协议SOAP提供了标准的RPC方法来调用Web Service。SOAP协议 = HTTP协议 + XML数据格式SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。soap协议分1.1和1.2版本:soap1.1:  请求方式:post  content-type:text/xml;charset=utf-8soap1.2:  请求方式:post  content-type:application/soap+xmlWSDL(Web Services Description Language):基于XML的语言，用于描述Web Service及其函数、参数和返回值。它是WebService客户端和服务器端都能理解的标准格式。WSDL文件保存在Web服务器上，通过一个url地址就可以访问到它。客户端要调用一个WebService服务之前，要知道该服务的WSDL文件的地址。注:wsdl文件阅读技巧:(从下往上读)  找到wsdl:service节点-&gt;查看下面的wsdl:port节点-&gt;查看其binding属性-&gt;找到与bingding名称相同的wsdl:binding节点  -&gt;查看节点下的wsdl:operation节点(对应的调用method名称)-&gt;wsdl:input方法输入参数节点-&gt;对应message属性值  -&gt;找到同名的wsdl:message节点-&gt;wsdl:part对应的参数名称和类型.  wsdl:output节点代表服务返回的数据.阅读方式和wsdl:input一致</code></pre><p>WebService优点:跨平台跨语言.服务方和调用方不用关心各自的平台和语言</p><p>WebService缺点:在使用方式上，RPC和soap的使用在减少，Restful架构占到了主导地位。在数据格式上，XML格式繁琐,使用在减少，json等轻量级格式的使用在增多..另外性能上略低(也有专门对xml解析优化的cpu)</p><h3 id="WebService的实现包有很多-Java语言有jdk1-6后内置的jws-Apache-cxf-Apache-Axis-Apache-Axis2"><a href="#WebService的实现包有很多-Java语言有jdk1-6后内置的jws-Apache-cxf-Apache-Axis-Apache-Axis2" class="headerlink" title="WebService的实现包有很多,Java语言有jdk1.6后内置的jws.*,Apache cxf,Apache Axis,Apache Axis2."></a>WebService的实现包有很多,Java语言有jdk1.6后内置的jws.*,Apache cxf,Apache Axis,Apache Axis2.</h3><p>本文采用axis2包,发布webservice服务可以采用jdk的@WebService注解实现或者cxf/axis/axis2来进行实现,网上教程很多,本文不涉及到这块.主要是发现在调用的时候会有一些坑,所以在此记录</p><p>WebService客户端调用主要有2类方式,一种是通过http远程调用,一种是通过wsdl2java产生Java代码调用</p><h4 id="1-远程调用"><a href="#1-远程调用" class="headerlink" title="1.远程调用"></a>1.远程调用</h4><p>  引入axisjar包:<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Axis2 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.axis2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>axis2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.ws.commons.axiom<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>axiom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.ws.commons.axiom<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>axiom-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.ws.commons.axiom<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>axiom-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>wsdl4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wsdl4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.ws.xmlschema<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xmlschema-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.neethi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>neethi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;version&gt;2.0.4&lt;/version&gt; --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.axis2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>axis2-transport-local<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.axis2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>axis2-transport-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.mail<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.mail-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Axis2 End --&gt;</span></span><br></pre></td></tr></table></figure></p><h5 id="1-1-axis2-wsdl地址方式调用"><a href="#1-1-axis2-wsdl地址方式调用" class="headerlink" title="1.1 axis2+wsdl地址方式调用:"></a>1.1 axis2+wsdl地址方式调用:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">String soapBindingAddress = <span class="string">"http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl"</span>;</span><br><span class="line">      EndpointReference endpointReference = <span class="keyword">new</span> EndpointReference(soapBindingAddress);</span><br><span class="line">      <span class="comment">//创建一个OMFactory</span></span><br><span class="line">      OMFactory factory = OMAbstractFactory.getOMFactory();</span><br><span class="line">      <span class="comment">//指定命名空间</span></span><br><span class="line">      OMNamespace namespace = factory.createOMNamespace(<span class="string">"http://WebXml.com.cn/"</span>, <span class="string">"web"</span>);</span><br><span class="line">      <span class="comment">//创建method对象，方法名 为getMobileCodeInfo</span></span><br><span class="line">      OMElement method = factory.createOMElement(<span class="string">"getMobileCodeInfo"</span>, namespace);</span><br><span class="line">      OMElement mobileCode = factory.createOMElement(<span class="string">"mobileCode"</span>, namespace);<span class="comment">//方法参数</span></span><br><span class="line">      OMElement userID = factory.createOMElement(<span class="string">"userID"</span>, namespace);<span class="comment">//方法参数</span></span><br><span class="line">      <span class="comment">//封装参数</span></span><br><span class="line">      mobileCode.addChild(factory.createOMText(mobileCode, <span class="string">"18265963256"</span>));<span class="comment">//设定参数的值</span></span><br><span class="line">      method.addChild(mobileCode);</span><br><span class="line">      userID.addChild(factory.createOMText(userID, <span class="string">""</span>));<span class="comment">//设定参数的值</span></span><br><span class="line">      method.addChild(userID);</span><br><span class="line">      <span class="comment">//请求参数设置</span></span><br><span class="line">      ServiceClient sender = <span class="keyword">new</span> ServiceClient();</span><br><span class="line">      Options options = <span class="keyword">new</span> Options();</span><br><span class="line">      <span class="comment">// 设置soap1.2协议</span></span><br><span class="line">      options.setSoapVersionURI(SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI);</span><br><span class="line">      options.setAction(<span class="string">"http://WebXml.com.cn/getMobileCodeInfo"</span>);</span><br><span class="line">      options.setTo(endpointReference);</span><br><span class="line">      sender.setOptions(options);</span><br><span class="line">      OMElement result = sender.sendReceive(method);</span><br><span class="line">      System.out.println(result.getFirstElement().getText());</span><br></pre></td></tr></table></figure><h5 id="1-2-axis2-endpoint地址方式调用"><a href="#1-2-axis2-endpoint地址方式调用" class="headerlink" title="1.2 axis2+endpoint地址方式调用:"></a>1.2 axis2+endpoint地址方式调用:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ServiceClient client = <span class="keyword">new</span> ServiceClient();</span><br><span class="line">      <span class="comment">// 创建服务地址WebService的URL,注意不是WSDL的URL</span></span><br><span class="line">      String url = <span class="string">"http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx"</span>;</span><br><span class="line">      EndpointReference targetEPR = <span class="keyword">new</span> EndpointReference(url);</span><br><span class="line">      Options options = client.getOptions();</span><br><span class="line">      <span class="comment">// 设置soap1.2协议</span></span><br><span class="line">      options.setSoapVersionURI(SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI);</span><br><span class="line">      options.setTo(targetEPR);</span><br><span class="line">      <span class="comment">// 确定调用方法（wsdl 命名空间地址 (wsdl文档中的targetNamespace) 和 方法名称 的组合）</span></span><br><span class="line">      options.setAction(<span class="string">"http://WebXml.com.cn/getMobileCodeInfo"</span>);</span><br><span class="line">      OMFactory fac = OMAbstractFactory.getOMFactory();</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 指定命名空间，参数： uri--即为wsdl文档的targetNamespace，命名空间 perfix--可不填</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      OMNamespace omNs = fac.createOMNamespace(<span class="string">"http://WebXml.com.cn/"</span>, <span class="string">""</span>);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 身份验证</span></span><br><span class="line"><span class="comment">       * OMElement header = fac.createOMElement("AuthenticationToken", omNs);</span></span><br><span class="line"><span class="comment">       * OMElement ome_user = fac.createOMElement("Username", omNs); OMElement</span></span><br><span class="line"><span class="comment">       * ome_pass = fac.createOMElement("Password", omNs);</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * ome_user.setText("user"); ome_pass.setText("pass");</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * header.addChild(ome_user); header.addChild(ome_pass);</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * client.addHeader(header);</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// 指定方法</span></span><br><span class="line">      OMElement method = fac.createOMElement(<span class="string">"getMobileCodeInfo"</span>, omNs);</span><br><span class="line">      <span class="comment">// 指定方法的参数</span></span><br><span class="line">      OMElement mobileCode = fac.createOMElement(<span class="string">"mobileCode"</span>, omNs);</span><br><span class="line">      mobileCode.setText(<span class="string">"18265963256"</span>);</span><br><span class="line">      OMElement userID = fac.createOMElement(<span class="string">"userID"</span>, omNs);</span><br><span class="line">      userID.setText(<span class="string">""</span>);</span><br><span class="line">      method.addChild(mobileCode);</span><br><span class="line">      method.addChild(userID);</span><br><span class="line">      method.build();</span><br><span class="line">      <span class="comment">// 远程调用web服务</span></span><br><span class="line">      OMElement result = client.sendReceive(method);</span><br><span class="line">      System.out.println(result);</span><br></pre></td></tr></table></figure><pre><code>注:返回的xml数据可能含有需要转义的字符,比如&amp;lt;之类的.可以用org.apache.commons.lang3.StringEscapeUtils.unescapeXml方法处理,(已过时),可以用commons-text包下的StringEscapeUtils类进行反转义处理</code></pre><h4 id="2-wsdl2java方式调用"><a href="#2-wsdl2java方式调用" class="headerlink" title="2.wsdl2java方式调用"></a>2.wsdl2java方式调用</h4><p>  使用jdk命令行下的wsimport命令和wsdl文件生成生成客户端中间代码,</p><p>  注意:只能编译soap1.1的协议，不能编译soap1.2的协议的代码</p><pre><code>wsimport [options] &lt;WSDL_URI&gt;比较常用的[options]有：1. -d &lt;directory&gt;  在指定的目录生成class文件2. -clientjar &lt;jarfile&gt;  在当前目录生成jar文件，结合-d &lt;directory&gt;可以在指定的目录生成jar文件3. -s &lt;directory&gt;  在指定的目录生成java源文件4. -p &lt;pkg&gt;  指定生成文件的包结构5. -keep  在生成class文件，或者jar包时，同时保留java源文件</code></pre><p>例:在当前目录新建class文件夹和java文件夹,分别存放对应的class文件个java文件</p><pre><code>wsimport -keep -d ./class -s ./java -p com.test.demo -verbose http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl  </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个MobileCodeWS工厂  </span></span><br><span class="line">MobileCodeWS factory = <span class="keyword">new</span> MobileCodeWS();  </span><br><span class="line"><span class="comment">//根据工厂创建一个MobileCodeWSSoap对象  </span></span><br><span class="line">MobileCodeWSSoap mobileCodeWSSoap = factory.getMobileCodeWSSoap();  </span><br><span class="line"><span class="comment">//调用WebService提供的getMobileCodeInfo方法查询手机号码的归属地  </span></span><br><span class="line">String searchResult = mobileCodeWSSoap.getMobileCodeInfo(<span class="string">"18265963256"</span>, <span class="keyword">null</span>);  </span><br><span class="line">System.out.println(searchResult);</span><br></pre></td></tr></table></figure><p>笔后摘要:</p><p>webservice既然是基于http的,那么也可使用最原始的URLconnect来进行访问请求处理,但是要注意对应的soap协议版本请求头,还需要组装符合soap协议xml文档信息等.完整的请求头应该和下例类似:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  请求头:</span><br><span class="line">  POST /WebServices/MobileCodeWS.asmx HTTP/1.1</span><br><span class="line">  Host: webservice.webxml.com.cn</span><br><span class="line">  Content-Type: text/xml; charset=utf-8</span><br><span class="line">  Content-Length: length</span><br><span class="line">  SOAPAction: "http://WebXml.com.cn/getMobileCodeInfo"</span><br><span class="line"></span><br><span class="line">消息体:</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:soap</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">getMobileCodeInfo</span> <span class="attr">xmlns</span>=<span class="string">"http://WebXml.com.cn/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mobileCode</span>&gt;</span>18265963256<span class="tag">&lt;/<span class="name">mobileCode</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">userID</span>&gt;</span>string<span class="tag">&lt;/<span class="name">userID</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">getMobileCodeInfo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> axis2 </tag>
            
            <tag> WebService </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debian系系统编译CuraEngine引擎</title>
      <link href="/2018/09/05/debian%E7%B3%BB%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91CuraEngine%E5%BC%95%E6%93%8E/"/>
      <url>/2018/09/05/debian%E7%B3%BB%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91CuraEngine%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:CuraEngine是一个功能强大、快速、强劲的3D模型切片引擎.Cura就是采用了CuraEngine引擎的.本文的操作环境为deepin 15.7,编译CuraEngine的版本为2.4</code></pre><p>1.安装cmake</p><pre><code>sudo apt install cmake</code></pre><p>2.安装Protobuf &gt;= 3.0.0 </p><p>  2.1 安装libtool</p><pre><code>sudo apt install libtool</code></pre><p>  2.2 安装autoconf</p><pre><code>sudo apt install autoconf</code></pre><p>  2.3 clone代码,–depth=1.clone最近一次提交的,可以减少clone时间</p><pre><code>git clone https://github.com/protocolbuffers/protobuf.git --depth=1</code></pre><p>  2.4 进入到protobuf目录.执行</p><pre><code>./autogen.sh</code></pre><p>  2.5 </p><pre><code>./configure</code></pre><p>  2.6 </p><pre><code>make </code></pre><p>  2.7 </p><pre><code>sudo make install</code></pre><p>3.安装libArcus</p><p>  3.1 安装python3-dev</p><pre><code>sudo apt install python3-dev</code></pre><p>  3.2 安装python3-sip-dev</p><pre><code>sudo apt install python3-sip-dev</code></pre><p>  3.3 安装libprotobuf-dev</p><pre><code>sudo apt install libprotobuf-dev</code></pre><p>  3.4 clone代码</p><pre><code>git clone https://github.com/Ultimaker/libArcus.git --depth=1</code></pre><p>  3.5 进入到libArcus目录,执行</p><pre><code>mkdir build &amp;&amp; cd buildcmake ..</code></pre><p>  3.6 </p><pre><code>make</code></pre><p>  3.7 </p><pre><code>sudo make install</code></pre><p>4.编译CuraEngine</p><p>  4.1 clone代码.此处编译2.4版本,-b指定版本</p><pre><code>git clone https://github.com/Ultimaker/CuraEngine.git -b 2.4 --depth=1</code></pre><p>  4.2 </p><pre><code>mkdir build &amp;&amp; cd build</code></pre><p>  4.3 </p><pre><code>cmake ..</code></pre><p>  4.4 </p><pre><code>make</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程tomcat配置jconsole连接监测jvm参数</title>
      <link href="/2018/08/20/%E8%BF%9C%E7%A8%8Btomcat%E9%85%8D%E7%BD%AEjconsole%E8%BF%9E%E6%8E%A5%E7%9B%91%E6%B5%8Bjvm%E5%8F%82%E6%95%B0/"/>
      <url>/2018/08/20/%E8%BF%9C%E7%A8%8Btomcat%E9%85%8D%E7%BD%AEjconsole%E8%BF%9E%E6%8E%A5%E7%9B%91%E6%B5%8Bjvm%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  jconsole是Java 自带性能监控工具，监视和管理控制台 jconsole，它可以提供 Java 某个进程的内存、线程、类加载、  jvm 概要以及 MBean 等的实时信息.  Jvisualvm是jdk1.6 update 7 才有，是jconsole的升级工具，功能更强大，最大好处是支持插件安装。所以Jvisualvm远程  JMX连接方式和jconsole远程连接方式一样</code></pre><p>1.在tomcat的bin目录下catalina.sh文件首部增加以下配置(注意:不用换行)</p><pre><code>CATALINA_OPTS=&quot;-Dfile.encoding=UTF-8 -server -Xms256m -Xmx256m -Djava.rmi.server.hostname=0.0.0.0 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=10001 -Dcom.sun.management.jmxremote.rmi.port=10001 -Dcom.sun.management.jmxremote.authenticate=true -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.password.file=./conf/jmxremote.password -Dcom.sun.management.jmxremote.access.file=./conf/jmxremote.access&quot;其中-Xms256m -Xmx256m是配置jvm虚拟机参数的,最小堆内存和最大堆内存,推荐保持一致,如果不一致会增加gc回收次数,对性能有严重影响.-Djava.rmi.server.hostname:本机的ip地址,可设置为0.0.0.0-Dcom.sun.management.jmxremote.port:监控的端口.不能和其他运行的端口相冲突-Dcom.sun.management.jmxremote.authenticate:需要授权才能进行连接-Dcom.sun.management.jmxremote.password.file:指定配置授权的密码文件存放位置,推荐放入到tomcat的conf目录下-Dcom.sun.management.jmxremote.access.file:指定配置授权账户的权限的文件存放位置,推荐放入到tomcat的conf目录下</code></pre><p>2.在tomcat的bin目录下startup.sh文件首部增加以下配置</p><pre><code>JAVA_OPTS=&quot;-Djava.rmi.server.hostname=0.0.0.0&quot;</code></pre><p>3.启动本地的jconsole即可,输入远程ip和端口,username和password即可连接</p><p>注意:</p><pre><code>1.配置授权的2个文件是在系统的%JAVA_HOME%/jre/lib/management目录下可以找到对应的模板.将其复制到tomcat的conf目录下,并将jmxremote.password.template重命名为jmxremote.password2.jmxremote.access用户权限分readonly和readwrite两种，在jmxremote.access尾部添加用户权限&quot;admin  readwrite&quot;,其中admin代表远程授权的用户名3.在jmxremote.password尾部添加用户密码&quot;admin 123456&quot;其中admin代表用户名,123456代表对应的密码4.对jmxremote.access和jmxremote.password文件进行授权,chmod 600  jmxremote.access和chmod 600 jmxremote.password5.针对为什么在startup.sh文件中增加对应的-Djava.rmi.server.hostname=0.0.0.0配置,主要是因为在不加配置的情况下,用shutdown.sh关闭tomcat的时候会报该端口已经被占用,因为关闭tomcat时候，还会读取catalina.sh.所以推荐在startup.sh文件中配置6.一般情况下远程服务器系统是开启防火墙的,所以还需要将10001端口配置为允许访问7.如果配置一切无误,还是连接不上的话,请将0.0.0.0换成对应的IP地址.因为亲测在Ubuntu下0.0.0.0能连接成功,但是在centos7下连接不成功</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> tomcat </tag>
            
            <tag> jconsole </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux系统之间远程连接和传输文件</title>
      <link href="/2018/08/07/linux%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%92%8C%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/"/>
      <url>/2018/08/07/linux%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%92%8C%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<pre><code>&gt;摘要: 1.Windows与Windows系统之间可以开启远程桌面连接实现远程控制和传输文件,也可以搭建ftp服务器然后通过ftp客户端(例如:fileZilla)来实现.2.从Windows到Linux,可以使用xshell等工具来实现远程连接.然后使用winscp等工具实现文件传输.当然在Linux上搭建ftp服务器,然后用ftp客户端连接也可3.从Linux(桌面版,server版一般没必要)到Windows.可以使用remmina工具来远程连接Windows进行连接操作.文件拷贝推荐在Windows上搭建ftpserver(fileZilla-server),然后使用fileZilla client连接传输文件. 注:fileZilla跨平台的.占用资源少,操作方便.简直神器~4.另外一种方式就是不分双方的操作系统.只要在对应的机器上安装对应的一些工具,比如teamviewer等.也可实现远程连接和文件传输.5.Linux到Linux之间通常是桌面端到server端的操作,有时候为了方便或者为了减少服务器资源占用,server端不需要安装额外的一些工具等,这时推荐使用Linux下的ssh和scp命令进行操作(大力推荐~)</code></pre><h2 id="1-ssh命令"><a href="#1-ssh命令" class="headerlink" title="1.ssh命令"></a>1.ssh命令</h2><p>  简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露.SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH(linux一般自带)，它是自由软件，应用非常广泛.注:ssh协议默认端口一般是22</p><pre><code>ssh -V 查看当前安装的ssh版本</code></pre><p>1.1 连接到远程主机方式1</p><pre><code>ssh username@serverAddress username是登录远程主机的用户名,serverAddress远程主机地址</code></pre><p>1.2 连接到远程主机方式2</p><pre><code>ssh serverAddress -l username -p 22 serverAddress远程主机地址,可以是一个域名地址或者ip地址,username是登录远程主机的用户名, -p 指定远程服务端ssh协议开放的端口.</code></pre><h2 id="2-scp命令"><a href="#2-scp命令" class="headerlink" title="2.scp命令"></a>2.scp命令</h2><pre><code>scp用于实现在Linux server端和Linux客户端实现文件传输</code></pre><p>2.1 上传文件到服务器端,注:是文件,不是文件夹</p><pre><code>scp ./test.js root@192.168.1.106:/var/www/ #将本地当前目录下的test.js文件上传到192.168.1.106的/var/www/目录下.root登录远程及其的用户名.</code></pre><p>2.2 上传文件夹(目录)到服务器端</p><pre><code>scp -r ./test/ root@192.168.1.106:/var/www/ #将本地当前目录下的test目录上传到192.168.1.106的/var/www/目录下.-r参数代表上传目录</code></pre><p>2.3 从服务器上下载文件</p><pre><code>scp root@192.168.1.106:/var/www/test.js /home/ #将服务器/var/www/目录下的test.js文件下载到本地的home目录下</code></pre><p>2.4 从服务器下载整个目录</p><pre><code>scp -r root@192.168.1.106:/var/www/test/ /home/ #将服务器上的/var/www/test/目录下载到本地的home目录下-r参数代表目录</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL新版本设置root密码和重置root密码</title>
      <link href="/2018/08/03/MySQL%E6%96%B0%E7%89%88%E6%9C%AC%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81%E5%92%8C%E9%87%8D%E7%BD%AEroot%E5%AF%86%E7%A0%81/"/>
      <url>/2018/08/03/MySQL%E6%96%B0%E7%89%88%E6%9C%AC%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81%E5%92%8C%E9%87%8D%E7%BD%AEroot%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<pre><code>&gt; 摘要:最近在虚拟机上安装Ubuntu18.04版本,然后安装MySQL-server.安装MySQL-server过程中不再像之前会提示输入root账户的密码.所以需要进行对root账户设置密码,&gt;操作环境:    OS:Ubuntu 18.04    MySQL版本:5.7及更高</code></pre><h3 id="1-前置条件"><a href="#1-前置条件" class="headerlink" title="1.前置条件"></a>1.前置条件</h3><pre><code>需要系统的root账户或者使用sudo 命令</code></pre><h3 id="2-使用mysql-secure-installation进行对密码设置"><a href="#2-使用mysql-secure-installation进行对密码设置" class="headerlink" title="2.使用mysql_secure_installation进行对密码设置"></a>2.使用mysql_secure_installation进行对密码设置</h3><pre><code>如果是第一次安装完MySQL后,可以使用:sudo mysql_secure_installation  对root账户进行设置密码操作</code></pre><h3 id="3-使用skip-grant-tables对root账户进行重置密码的操作"><a href="#3-使用skip-grant-tables对root账户进行重置密码的操作" class="headerlink" title="3.使用skip-grant-tables对root账户进行重置密码的操作"></a>3.使用skip-grant-tables对root账户进行重置密码的操作</h3><pre><code>3.1 停止当前正在运行的mysql服务    sudo service mysql stop3.2 创建/var/run/mysqld目录,因为MySQL进程在启动和运行的时候都需要访问该soket文件    sudo mkdir -p /var/run/mysqld    sudo chown mysql:mysql /var/run/mysqld3.3 使用skip-grant-tables启动服务程序    sudo /usr/sbin/mysqld --skip-grant-tables --skip-networking &amp;    jobs 然后确认下服务是否启动成功3.4 使用root无密码登录,进行修改设置密码操作    mysql -u root root无密码登录    FLUSH PRIVILEGES; 刷新一遍授权信息    USE mysql; 切换到mysql库(安装好后自带的)    UPDATE user SET authentication_string=PASSWORD(&quot;123456&quot;) WHERE User=&apos;root&apos;; 设置密码字段的新密码,    authentication_string是新版本存储密码的字段名,旧版本的是password.    UPDATE user SET plugin=&quot;mysql_native_password&quot; WHERE User=&apos;root&apos;;    FLUSH PRIVILEGES;    quit;3.5 重启MySQL服务    sudo pkill mysqld  停掉之前启动的服务    jobs 查看是否正确停止服务    sudo service mysql start 启动MySQL服务3.6 使用root账户和刚设置的密码进行登录操作    mysql -u root --password=123456  使用root和密码登录</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>atom配置vue前端开发环境</title>
      <link href="/2018/06/25/atom%E9%85%8D%E7%BD%AEvue%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/06/25/atom%E9%85%8D%E7%BD%AEvue%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  使用atom配置前端vue开发环境</code></pre><p>1.安装好atom后,安装常用的几个插件</p><pre><code>prettier-atom : 格式化代码插件atom-axios : vue-axios提示插件autoclose-html : 自定补全闭合html标签插件file-icons : 文件图标,便利区分不同类型的文件autocomplete-paths : 自动提示补全文件路径插件language-vue : atom支持vue的插件language-vue-component : 高亮显示vue组件插件vue2-autocomplete : vue2.0+提示插件linter-eslint : eslint规则校验插件px2rem-plus : px转rem插件minimap : 在编辑器右边出现预览源代码(类似sublime text3右侧预览导航效果)的插件下面是支持markdown的插件:markdown-toc : 对markdown文档生成目录的插件markdown-table-editor : markdown文档表格编辑插件</code></pre><p>2.安装好对应的插件后,大部分情况能够使用,但是vue项目需要支持eslint校验的话,需要对linter-eslint设置下面的 Lint-HTML-Files进行勾选</p><p><img src="/images/eslint.png" alt></p><p>3.默认的prettier格式化的规则是不符合eslint的,比如会对每行尾部增加分号,单引号变变为双引号,需要修改其配置为下:</p><p><img src="/images/prettier.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> atom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java实现图片的灰度化处理</title>
      <link href="/2018/06/12/java%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/"/>
      <url>/2018/06/12/java%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E7%81%B0%E5%BA%A6%E5%8C%96%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:24位彩色图与8位灰度图在一个24位彩色图像中，每个像素由三个字节表示，通常表示为RGB。通常，许多24位彩色图像存储为32位图像，每个像素多余的字节存储为一个alpha值，表现有特殊影响的信息在RGB模型中，如果R=G=B时，则彩色表示一种灰度颜色，其中R=G=B的值叫灰度值，因此，灰度图像每个像素只需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255.这样就得到一幅图片的灰度图</code></pre><p>常见的几种灰度化的方法:</p><pre><code>分量法：使用RGB三个分量中的一个作为灰度图的灰度值。最值法：使用RGB三个分量中最大值或最小值作为灰度图的灰度值。均值法：使用RGB三个分量的平均值作为灰度图的灰度值。加权法：由于人眼颜色敏感度不同，按下一定的权值对RGB三分量进行加权平均能得到较合理的灰度图像。一般情况按照：Y = 0.30R + 0.59G + 0.11B.加权法实际上是取一幅图片的亮度值人眼对绿色的敏感最高，对蓝色敏感最低 ）作为灰度值来计算，用到了YUV模型</code></pre><p>java编码实现图片灰度化</p><p>1.强制设置灰度化的方法（效果相对就差）</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片灰化（效果不行，不建议。据说：搜索“Java实现灰度化”，十有八九都是一种方法）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bufferedImage 待处理图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BufferedImage <span class="title">grayImage</span><span class="params">(BufferedImage bufferedImage)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> width = bufferedImage.getWidth();  </span><br><span class="line">    <span class="keyword">int</span> height = bufferedImage.getHeight();  </span><br><span class="line"></span><br><span class="line">    BufferedImage grayBufferedImage = <span class="keyword">new</span> BufferedImage(width, height,</span><br><span class="line">                                    BufferedImage.TYPE_BYTE_GRAY);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span> ; y &lt; height; y++) &#123;  </span><br><span class="line">        grayBufferedImage.setRGB(x, y, bufferedImage.getRGB(x, j));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>2.加权法灰度化（效果较好）</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片灰化（参考：http://www.codeceo.com/article/java-image-gray.html）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bufferedImage 待处理图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BufferedImage <span class="title">grayImage</span><span class="params">(BufferedImage bufferedImage)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">  Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> width = bufferedImage.getWidth();</span><br><span class="line"><span class="keyword">int</span> height = bufferedImage.getHeight();</span><br><span class="line">BufferedImage grayBufferedImage = <span class="keyword">new</span> BufferedImage(width, height,</span><br><span class="line">                                    BufferedImage.TYPE_BYTE_GRAY);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; height; y++) &#123;</span><br><span class="line"><span class="comment">// 计算灰度值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> color = bufferedImage.getRGB(x, y);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> r = (color &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> g = (color &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> b = color &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="keyword">int</span> gray = (<span class="keyword">int</span>) (<span class="number">0.3</span> * r + <span class="number">0.59</span> * g + <span class="number">0.11</span> * b);</span><br><span class="line"><span class="keyword">int</span> newPixel = colorToRGB(<span class="number">255</span>, gray, gray, gray);</span><br><span class="line">grayBufferedImage.setRGB(x, y, newPixel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> grayBufferedImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 颜色分量转换为RGB值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> alpha</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> red</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> green</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> blue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">colorToRGB</span><span class="params">(<span class="keyword">int</span> alpha, <span class="keyword">int</span> red, <span class="keyword">int</span> green, <span class="keyword">int</span> blue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> newPixel = <span class="number">0</span>;</span><br><span class="line">newPixel += alpha;</span><br><span class="line">newPixel = newPixel &lt;&lt; <span class="number">8</span>;</span><br><span class="line">newPixel += red;</span><br><span class="line">newPixel = newPixel &lt;&lt; <span class="number">8</span>;</span><br><span class="line">newPixel += green;</span><br><span class="line">newPixel = newPixel &lt;&lt; <span class="number">8</span>;</span><br><span class="line">newPixel += blue;</span><br><span class="line"><span class="keyword">return</span> newPixel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL设置用户远程登录</title>
      <link href="/2018/06/12/MySQL%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"/>
      <url>/2018/06/12/MySQL%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:在Linux(debian)下,通过apt install mysql-server后,输入root账户密码后,默认是不允许远程登录的.可以用过以下几种方式来设置允许能够远程登录</code></pre><p>1.改mysql库下的user表的数据</p><pre><code>mysql -u root –pmysql&gt;use mysql;mysql&gt;update user set host = &apos;%&apos; where user = &apos;root&apos;;mysql&gt;select host, user from user;</code></pre><p>2.通过授权的方式,这种方式可以对不同的用户设置不同的访问权限</p><pre><code>#例如: 在MySQL服务器主机上执行,允许root使用123456从任何主机连接到mysql服务器mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION;mysql&gt;FLUSH PRIVILEGES; # 刷新权限,使配置生效#例如:允许用户test从ip为120.77.163.89的主机连接到mysql服务器，并使用123456作为密码mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &apos;test&apos;@’120.77.163.89’ IDENTIFIED BY &apos;654321&apos; WITH GRANT OPTION;mysql&gt;FLUSH PRIVILEGES; # 刷新权限,使配置生效</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell基础</title>
      <link href="/2018/05/20/Shell%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/05/20/Shell%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  Shell是一个命令行解释器,它为用户提供了一个向Linux内核  发送请求以便运行程序的界面系统级程序.用户可以用Shell来启动,挂起,  停止甚至是编写一些程序.  Shell还是一个功能相当强大的编程语言.易编写,意调试,灵活性较强.  Shell是解释执行的语言,在Shell中可以直接调用Linux系统命令.</code></pre><h4 id="1-脚本的执行方式"><a href="#1-脚本的执行方式" class="headerlink" title="1.脚本的执行方式"></a>1.脚本的执行方式</h4><pre><code>1. echo 输出命令    echo [选项] [输出内容]    选项:      -e : 支持反斜杠控制的字符转换2. 编写第一个脚本  vim hello.sh  #!/bin/bash  # this is hello program!  echo &quot;hello&quot;3. 脚本执行  1.赋予执行权限      chmod 755 ./hello.sh    ./hello.sh  2.通过bash调用执行脚本    bash ./hello.sh  3.使用sh命令执行    sh ./hello.sh</code></pre><h4 id="2-Bash的基本功能"><a href="#2-Bash的基本功能" class="headerlink" title="2.Bash的基本功能"></a>2.Bash的基本功能</h4><pre><code>1. 命令的别名,很多泛指为Linux下的命令,其实本质是属于Bash  `alias` 查看系统中所有的命令的别名2. 设置命令别名  alias 别名= &apos;原命令&apos;  alias ll=&apos;ls -l&apos;  #给ls -l 设置别名ll  以上设置别名的方式只是当次有效,系统重启后无效.要设置别名永久有效,  可以写入环境变量中  vim ~/.bashrc  alias ll=&apos;ls -l&apos;  保存,执行source ~/.bashrc即可3. 删除别名  unalias 别名  unalias ll  unalias是删除临时别名的,永久生效的别名需要删除环境变量中的配置4. 命令的生效顺序  第一顺位执行用绝对路径或者相对路径的命令  第二顺位执行别名  第三顺位执行Bash的内部命令  第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令  注:因为别名的执行顺序是高于$PATH下的命令的,  所以一般情况下请勿将别名设为与其他原始命令相同的命令.</code></pre><h4 id="3-Shell编程之Bash变量"><a href="#3-Shell编程之Bash变量" class="headerlink" title="3.Shell编程之Bash变量"></a>3.Shell编程之Bash变量</h4><p>  Shell中,所有变量默认都是字符串类型</p><ol><li><p>用户自定义变量  变量名=变量值(等号2边不能有空格)</p><p>用户自己定义的变量,变量名和值可随意更改</p><p>name=”zhangsan”</p><p>echo $name #显示name的值</p><p>1.1 变量叠加</p><p> name=”$name”isaname</p><p>1.2  删除变量(释放变量的内存地址) unset 变量名</p></li><li><p>环境变量</p><p>环境变量是全局变量,用户可更改值,不能更改名称</p></li><li><p>位置参数变量</p><p>$n :n为数字,$0代表命令本身.$1-$9代表第1-第9个参数,10以上的参数需要用大括号包含,如${10}</p><p>例:vim sum.sh</p><p> `#!/bin/bash</p><p>   num1=$1</p><p>   num2=$2</p><p>   sum=$(($num1+$num2))</p><p>   #变量sum的和是num1+num2</p><p>   echo $sum`</p><p>   执行;./sum.sh 10 20  #./sum.sh是$0,10是$1,20是$2</p><p>   结果:30</p><p>$<em> : 这个变量代表命令行中中所有的参数,$</em> 把所有的参数看成一个整体</p><p>$@ : 这个变量也代表命令行中所有的参数,不过$@ 是把每个参数区分对待</p><p>@# : 这个变量代表命令行中所有参数的个数</p><p>例:vim /demo.sh</p><p>`#!/bin/bash</p><p>echo “参数是: $* “</p><p>echo “参数也是: $@ “</p><p>echo “参数个数是: $#”`</p><p>执行;./demo.sh 11 22 33</p><p>结果:参数是: 11 22 33 参数也是: 11 22 33 参数个数是: 3</p><p>$* 和 $@ 区别</p><p>vim ./demo.sh</p><p>#!/bin/bash</p><p>`for i in “$*”</p><p>#$* 把所有的参数看成一个整体,所以执行循环1次</p><p> do</p><p>   echo “参数是: $i”</p><p> done</p><p>for y in “$@”</p><p>#$@ 是把每个参数区分对待,所有有几个参数就循环几次</p><p> do</p><p>   echo “参数是: $y”</p><p> done<br>`</p></li><li><p>预定义变量</p><p>$? : 最后依次执行的命令的返回结果,如果返回是0,代表上一个命令执行成功,如果返回是非0,代表上一个命令执行失败</p><p>$$ : 返回当前进程的PID号</p><p>$! : 后台运行的最后一个进程的进程号(PID)</p></li><li><p>接收键盘输入:read 命令</p><p>read [选项] [变量名]</p><p>选项</p><p> -p “提示信息”:在等待read输入时,输出提示信息</p><p> -t 秒数: read命令会一直等待用户输入,输入次选项可以指定用户等待时间</p><p> -n 字符数: read命令只接受指定的字符数,就会执行</p><p> -s : 隐藏输入的数据,适用于输入密码等情况</p></li></ol><h4 id="4-Shell编程之运算符"><a href="#4-Shell编程之运算符" class="headerlink" title="4.Shell编程之运算符"></a>4.Shell编程之运算符</h4><pre><code>1. declare命令  declare声明变量类型  declare [+/-] [选项] 变量名    选项:用-给变量设定类型属性,用+取消变量的类型属性  常见选项类型    -a 将变量声明为数组类型    -i 将变量声明为整形    -x 将变量声明为环境变量    -r 将变量声明为只读变量(设置为只读属性后,不能对变量进行删除,修改,取消属性的操作)    -p 查看显示指定变量的被声明的类型2. 数值运算的方法  方法1:  [root@localhost~]# aa=11  [root@localhost~]# bb=22  [root@localhost~]# declare -i cc=$aa+$bb  方法2:    expr或者let数值运算工具    [root@localhost~]# aa=11    [root@localhost~]# bb=22    [root@localhost~]# dd=$(expr $aa + $bb)    #dd的值是aa和bb的和,注意:&quot;+&quot;号两侧必须有空格  方法3:    &quot;$(())&quot;或&quot;$[运算式]&quot;    [root@localhost~]# aa=11    [root@localhost~]# bb=22    [root@localhost~]# cc=$(($aa + $bb))    [root@localhost~]# gg=$[$aa + $bb]3. 变量测试(只是针对Shell,其他常用不适用.一般不常用,对脚本进行优化的时候才使用)</code></pre><h4 id="5-Shell编程之环境变量配置文件"><a href="#5-Shell编程之环境变量配置文件" class="headerlink" title="5.Shell编程之环境变量配置文件"></a>5.Shell编程之环境变量配置文件</h4><pre><code>`/etc/profile/etc/profile.d/*.sh/etc/bashrc~/.bashrc~/.bash_profile`/etc目录下的是系统环境变量文件,~目录下的是当前用户的环境变量配置文件</code></pre><h4 id="6-Shell编程之正则表达式"><a href="#6-Shell编程之正则表达式" class="headerlink" title="6.Shell编程之正则表达式"></a>6.Shell编程之正则表达式</h4><pre><code>正则表达式主要是用于描述字符排列和匹配模式d额一种语法规则，主要用于字符串的模式分割,匹配,查找及替换操作</code></pre><p>  1.正则表达式与通配符</p><pre><code>通配符：  *：匹配任意内容  ?：匹配任意一个内容  []：匹配括号中的一个字符.</code></pre><p>  正则表达式用来在文件中匹配符合条件的字符串,正则是包含匹配.<br>  grep,awk,sed等命令可以支持正则表达式.</p><p>  通配符用来匹配符合条件的文件名,通配符是完全匹配.<br>  ls,find,cp这些命令不支持正则表达式,所以只能使用shell的通配符匹配.</p><h4 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式:"></a>基础正则表达式:</h4><table><thead><tr><th>元字符</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>*</td><td style="text-align:center">前一个字符匹配0次或者任意多次</td></tr><tr><td>.</td><td style="text-align:center">匹配除了换行符以外的任意一个字符</td></tr><tr><td>^</td><td style="text-align:center">匹配行首.例如:^hello匹配以hello开头的行</td></tr><tr><td>$</td><td style="text-align:center">匹配行尾.例如:hello$匹配以hello结尾的行</td></tr><tr><td>[]</td><td style="text-align:center">匹配中括号中指定的任意一个字符,只匹配一个字符</td></tr><tr><td>[^]</td><td style="text-align:center">匹配除中括号中的字符以外的任意一个字符,例:[^0-9]表示匹配任意一位非数字字符</td></tr><tr><td>\</td><td style="text-align:center">转义符,用于将特殊符号的含义取消</td></tr><tr><td>\{n\}</td><td style="text-align:center">表示其前面的字符恰好出现n次.例:[0-9]\{4\}匹配4位数字</td></tr><tr><td>\{n,\}</td><td style="text-align:center">表示其前面出现的字符不小于n次,例:[0-9]\{2,\}表示2位及以上的数字</td></tr><tr><td>\{n,m\}</td><td style="text-align:center">表示其前面出现的字符至少出现n次,最多出现m次,例:[a-z]\{2,4\}匹配2到4位的小写字母</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用压缩解压缩</title>
      <link href="/2018/05/20/Linux%E5%B8%B8%E7%94%A8%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
      <url>/2018/05/20/Linux%E5%B8%B8%E7%94%A8%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  Linux下常用的压缩格式有:.zip .gz .bz2 .tar.gz .tar.bz2</code></pre><h4 id="1-zip格式压缩"><a href="#1-zip格式压缩" class="headerlink" title="1 .zip格式压缩"></a>1 .zip格式压缩</h4><p>压缩文件 <code>zip 压缩文件名 源文件</code></p><pre><code>zip test.zip ./test.txt #将当前目录的test.txt文档压缩为test.zip</code></pre><p>压缩目录 <code>zip -r 压缩文件名 源目录</code></p><pre><code>zip test1.zip ./test1 #将当前目录的test1目录压缩为test1.zip</code></pre><h4 id="2-zip格式解压缩"><a href="#2-zip格式解压缩" class="headerlink" title="2 .zip格式解压缩"></a>2 .zip格式解压缩</h4><p>解压文件  <code>unzip 压缩文件</code></p><pre><code>zip ./test1.zip #解压缩当前目录的test1.zip文件</code></pre><h4 id="3-gz格式压缩"><a href="#3-gz格式压缩" class="headerlink" title="3 .gz格式压缩"></a>3 .gz格式压缩</h4><p>压缩为.gz文件,源文件消失  <code>gzip 源文件</code></p><p>压缩为.gz文件,源文件保留  <code>gzip -c 源文件 &gt; 压缩文件</code></p><p>压缩目录下的所有子文件,但是不能压缩目录  <code>gzip -r 目录</code></p><h4 id="4-gz格式解压缩"><a href="#4-gz格式解压缩" class="headerlink" title="4 .gz格式解压缩"></a>4 .gz格式解压缩</h4><p>解压缩.gz文件  <code>gzip -d 压缩文件</code></p><p>解压缩.gz文件  <code>gunzip  压缩文件</code></p><h4 id="5-bz2格式压缩"><a href="#5-bz2格式压缩" class="headerlink" title="5 .bz2格式压缩"></a>5 .bz2格式压缩</h4><p>压缩为.bz2格式,不保留源文件  <code>bzip2 源文件</code></p><p>压缩为.bz2格式,保留源文件 <code>bzip2 -k 源文件</code></p><p>注:bzip2不能压缩目录</p><h4 id="6-bz2格式解压缩"><a href="#6-bz2格式解压缩" class="headerlink" title="6 .bz2格式解压缩"></a>6 .bz2格式解压缩</h4><p>解压缩.bz2文件,-k保留压缩文件  <code>bzip2 -d 压缩文件</code></p><p>解压缩.bz2文件,-k保留压缩文件  <code>bunzip2 压缩文件</code></p><h4 id="7-tar-gz格式压缩-先打包为tar-再压缩为-gz文件"><a href="#7-tar-gz格式压缩-先打包为tar-再压缩为-gz文件" class="headerlink" title="7 .tar.gz格式压缩(先打包为tar,再压缩为.gz文件)"></a>7 .tar.gz格式压缩(先打包为tar,再压缩为.gz文件)</h4><p>tar打包命令  <code>tar -cvf 打包文件名 源文件</code></p><p>选项: -c 打包; -v 现实过程; -f 指定打包后的文件名</p><p>tar -cvf test.tar ./test 将当前目录下test目录打包为tar文件</p><p>gzip test.tar  生成test.tar.gz文件</p><p>bzip2 test.tar 生成test.tar.bz2文件</p><p>上述过程繁琐,可以直接用  <code>tar -zcvf 压缩包名.tar.gz 源文件</code></p><h4 id="8-tar-gz格式解压缩-先用gzip解压文件-然后解打包"><a href="#8-tar-gz格式解压缩-先用gzip解压文件-然后解打包" class="headerlink" title="8 .tar.gz格式解压缩(先用gzip解压文件,然后解打包)"></a>8 .tar.gz格式解压缩(先用gzip解压文件,然后解打包)</h4><p>解打包命令  <code>tar -xvf 打包文件名</code></p><p>选项: -x 解打包</p><p>tar -vxf test.tar   解包text.tar文件</p><p>上述过程繁琐,可以直接用  <code>tar -zxvf 压缩包名.tar.gz</code>,<br>解压到指定目录可用-C选项指定目录 <code>tar -zxvf 压缩包名.tar.gz -C /tmp/</code></p><h4 id="9-tar-bz2格式压缩-先打包为tar-再压缩为-bz2文件"><a href="#9-tar-bz2格式压缩-先打包为tar-再压缩为-bz2文件" class="headerlink" title="9 .tar.bz2格式压缩(先打包为tar,再压缩为.bz2文件)"></a>9 .tar.bz2格式压缩(先打包为tar,再压缩为.bz2文件)</h4><p>tar打包命令  <code>tar -cvf 打包文件名 源文件</code></p><p>选项: -c 打包; -v 现实过程; -f 指定打包后的文件名</p><p>tar -cvf test.tar ./test 将当前目录下test目录打包为tar文件</p><p>bzip2 test.tar 生成test.tar.bz2文件</p><p>上述过程繁琐,可以直接用  <code>tar -jcvf 压缩包名.tar.bz2 源文件</code></p><h4 id="10-tar-bz2格式解压缩-先用bzip2解压文件-然后解打包"><a href="#10-tar-bz2格式解压缩-先用bzip2解压文件-然后解打包" class="headerlink" title="10 .tar.bz2格式解压缩(先用bzip2解压文件,然后解打包)"></a>10 .tar.bz2格式解压缩(先用bzip2解压文件,然后解打包)</h4><p>解打包命令  <code>tar -xvf 打包文件名</code></p><p>选项: -x 解打包</p><p>tar -vxf test.tar   解包text.tar文件</p><p>上述过程繁琐,可以直接用  <code>tar -jxvf 压缩包名.tar.bz2</code>,<br>解压到指定目录可用-C选项指定目录 <code>tar -jxvf 压缩包名.tar.bz2 -C /tmp/</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下nginx部署配置多站点</title>
      <link href="/2018/05/13/linux%E4%B8%8Bnginx%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%AB%99%E7%82%B9/"/>
      <url>/2018/05/13/linux%E4%B8%8Bnginx%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%AB%99%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  有时候你想在一台服务器上为不同的域名运行不同的站点。  比如www.siteA.com作为博客，www.siteB.com作为论坛。你可以把两个域名的IP都解析到你的服务器上，  但是没法在Nginx的根目录里同时运行两个不同的网站.  这时可以在nginx上面配置部署多个站点(使用nginx虚拟目录),为你节省服务器费用.  假设你把博客放在”/home/user/www/blog”下，论坛放在”/home/user/www/forum”下。下面我们就开始进行配置:</code></pre><p>1.在Nginx配置目录下，创建一个”vhost”目录。本例假设Nginx是默认安装，配置目录在”/etc/nginx”</p><p><code>sudo mkdir /etc/nginx/vhost #创建保存站点配置文件的目录</code></p><p>2.创建siteA的配置文件</p><p>‘sudo vim /etc/nginx/vhost/siteA.conf #打开该文件(没有的话保存后会自动新建)’</p><p>在文件里面输入以下配置内容(具体的相关目录及location内容根据自己实际情况修改,下面只是nginx配置文件的基本结构,其实可以拷贝nginx自带的配置文件到vhost目录下,然后对文件内容进行修改):</p><pre><code>server {  listen 80; # 监听端口  server_name www.siteA.com siteA.com; # 站点域名  root /home/user/www/blog; # 站点根目录  index index.html index.htm index.php; # 默认导航页  #rewrite ^(.*) https://$host$1 permanent; #重定向到https  location / {    # WordPress固定链接URL重写    if (!-e $request_filename) {      rewrite (.*) /index.php;    }  }  location / {    # WordPress固定链接URL重写    if (!-e $request_filename) {      rewrite (.*) /index.php;    }  }  location ^~ /device/ {      proxy_pass http://127.0.0.1:8080;  }  location ^~ /upload/ {      root  /aaa/bbb;    expires   7d;  }}</code></pre><p>3.跟第二步一样,创建siteB的配置文件.(“server_name”和”root”目录的内容和siteA不同)</p><p>‘sudo vim /etc/nginx/vhost/siteB.conf #打开该文件(没有的话保存后会自动新建)’</p><p>在文件里面输入以下配置内容(具体的相关目录及location内容根据自己实际情况修改,下面只是nginx配置文件的基本结构,其实可以拷贝nginx自带的配置文件到vhost目录下,然后对文件内容进行修改):</p><pre><code>server {  listen 80; # 监听端口  server_name www.siteB.com siteB.com; # 站点域名  root /home/user/www/blog; # 站点根目录  index index.html index.htm index.php; # 默认导航页  #rewrite ^(.*) https://$host$1 permanent; #重定向到https  location / {    # WordPress固定链接URL重写    if (!-e $request_filename) {      rewrite (.*) /index.php;    }  }  location ^~ /device/ {      proxy_pass http://127.0.0.1:8080;  }  location ^~ /upload/ {      root  /aaa/bbb;    expires   7d;  }  # websocket地址  location ^~ /ws {        proxy_pass http://127.0.0.1:10002;    }}</code></pre><p>4.打开编辑nginx的配置文件</p><p><code>sudo vim /etc/nginx/nginx.conf</code></p><p>将我们第一步创建的虚拟目录的路径增加到nginx.conf文件中去,将下面的内容加入到”http {}”部分的末尾</p><pre><code>http {  ...  include /etc/nginx/vhost/*.conf;}</code></pre><p>5.重启nginx服务(注意:所有的配置文件修改保存后,先不急重新加载配置,先使用<code>nginx -t</code>测试下文件内容是否有错在进行重新加载配置操作)</p><p><code>sudo service nginx restart</code></p><p>6.访问<a href="http://www.siteA.com和www.siteB.com，你将发现浏览器会打开不同的站点" target="_blank" rel="noopener">www.siteA.com和www.siteB.com，你将发现浏览器会打开不同的站点</a></p><p>nginx禁止ip访问的小技巧:</p><p>假如你的Nginx根目录设在”/home/user/www”，你想阻止别人通过”<a href="http://IP地址/blog”或”http://IP地址/forum”来访问你的站点，最简单的方法就是禁止IP地址访问。方法如下：" target="_blank" rel="noopener">http://IP地址/blog”或”http://IP地址/forum”来访问你的站点，最简单的方法就是禁止IP地址访问。方法如下：</a></p><p>打开Nginx网站默认配置文件，记得先备份</p><p><code>sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/default_bak #备份原来的默认文件</code></p><p><code>sudo vim /etc/nginx/sites-available/default #编辑文件</code></p><p>将其所有内容删除，只留以下配置</p><pre><code>server {  listen 80 default_server;  server_name _;  return 404;}</code></pre><p>然后重启nginx或者<code>nginx -s reload</code>使配置文件生效,别人将无法通过IP地址访问网站了</p><p>如果你不想禁止IP地址访问整个目录，只是要防止别人通过IP访问你的博客和论坛。那就需要禁止”/blog”和”/forum”的目录访问</p><p>打开Nginx网站默认配置文件，同上面一样，记得先备份一下</p><p>在”server { }”节点的部分加上以下配置,然后重启nginx或者reload nginx配置即可.</p><pre><code>location ^~ /blog/ {  deny all;}location ^~ /forum/ {  deny all;}</code></pre><p>7.nginx常用的配置选项模板<br>    /etc/nginx/nginx.conf</p><pre><code>http {  sendfile on;  tcp_nopush on;  tcp_nodelay on;  keepalive_timeout 65;  types_hash_max_size 2048;  server_tokens off; # 关闭nginx版本标识  underscores_in_headers on; #自定义Header中含有下划线的情况 必须定义  gzip  on;  gzip_min_length 1k;  gzip_buffers 16 64k;  gzip_http_version 1.1;  gzip_comp_level 6;  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;  gzip_vary on;  gzip_disable &quot;MSIE [1-6]\.&quot;;  #proxy_connect_timeout 600;  #nginx跟后端服务器连接超时时间(代理连接超时)  proxy_buffer_size     32k;  #设置代理服务器（nginx）保存用户头信息的缓冲区大小  proxy_buffers         4 32k;#proxy_buffers缓冲区，网页平均在32k以下的话，这样设置  proxy_busy_buffers_size  64k;           #高负荷下缓冲大小（proxy_buffers*2）  proxy_temp_file_write_size  1024m;       #设定缓存文件夹大小，大于这个值，将从upstream服务器传  client_max_body_size 100M;  # 给后端服务器暴露获取客户端真实IP地址的头  proxy_set_header X-Real-IP $remote_addr;  proxy_set_header REMOTE-HOST $remote_addr;  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  # websocket 支持  proxy_http_version 1.1;  proxy_set_header Upgrade $http_upgrade;  proxy_set_header Connection &quot;upgrade&quot;;  proxy_read_timeout    600;  #连接成功后，后端服务器响应时间(代理接收超时)  proxy_send_timeout    600;  #后端服务器数据回传时间(代理发送超时)}</code></pre><p>8.站点配置文件样例,例如:/etc/nginx/vhost/a.conf</p><pre><code>server {  listen          80;  server_name     www.aaa.com  aaa.com;  root            /opt/pages/;  index           index.html index.htm;  # Cookie的HttpOnly属性，指示浏览器不要在除HTTP（和HTTPS)请求之外暴露Cookie。一个有HttpOnly属性的Cookie，是不可以通过例如调用JavaScript(引用document.cookie)这种非HTTP方式来访问。因此，也不可能通过跨域脚本（一种非常普通的攻击技术）来偷走这种Cookie。  add_header                  Set-Cookie &quot;HttpOnly&quot;;  # Cookie的Secure属性，意味着保持Cookie通信只限于加密传输，指示浏览器仅仅在通过安全/加密连接才能使用该Cookie。如果一个Web服务器从一个非安全连接里设置了一个带有secure属性的Cookie，当Cookie被发送到客户端时，它仍然能通过中间人攻击来拦截  add_header                  Set-Cookie &quot;Secure&quot;;  # X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 &lt;frame&gt;, &lt;iframe&gt; 或者 &lt;object&gt; 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。它有三个可选择项：(DENY：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许；SAMEORIGIN：表示该页面可以在相同域名页面的 frame 中展示；ALLOW-FROM uri地址：表示该页面可以在指定来源的 frame 中展示；)  add_header                  X-Frame-Options &quot;SAMEORIGIN&quot;;  # 禁用OPTIONS TRACE不安全方法,屏蔽GET、POST、之外的HTTP方法  if ($request_method !~* GET|POST) {      return 403;  }  # 跨域配置  location / {    add_header Access-Control-Allow-Origin *;    add_header Access-Control-Allow-Methods &apos;GET, POST, OPTIONS&apos;;    add_header Access-Control-Allow-Headers &apos;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&apos;;    if ($request_method = &apos;OPTIONS&apos;) {      return 204;    }  }  # 转发以/api/开头的请求  location ^~ /api/ {    proxy_pass http://127.0.0.1:8080;  }  # 以/upload开头的请求  location ^~ /upload/ {    root  /opt/dir/;    expires   7d;  }}</code></pre><p>9.nginx负载均衡配置</p><p>  在http节点下配置服务器列表</p><pre><code>http {  # upstream模块：配置反向代理服务器组，Nginx会根据配置，将请求分发给组里的某一台服务器。serverGroup是服务器组的名称.  upstream serverGroup {    server 192.168.0.100:8080;    server 192.168.0.101:8080;  }  # serverGroup内部的server指令：配置处理请求的服务器IP或域名，端口可选，不配置默认使用80端口。通过上面的配置(默认的是轮询策略,把每个请求逐一分配到不同的server，如果分配到的server不可用，则分配到下一个，直到可用)，Nginx默认将请求依次分配给100，101来处理，可以通过修改下面这些参数来改变默认的分配策略：  1.weight权重,默认为1，将请求平均分配给每台server.值越大，则被访问的概率越大.下面标示101访问数量是100的2倍  upstream serverGroup {    server 192.168.0.100:8080 weight=1;    server 192.168.0.101:8080 weight=2 max_fails=3 fail_timeout=15;    server 192.168.0.102:8080 down; #down 表示当前服务器不参与负载均衡，也就是说不会被访问到    server 192.168.0.103:8080 backup; #backup 表示备份机，所有服务器挂了之后才会生效  }  max_fails:默认为1。某台Server允许请求失败的次数，超过最大次数后，在fail_timeout时间内，新的请求将不会分配给这台机器。如果设置为0，Nginx会将这台Server置为永久无效状态，然后将请求发给定义了proxy_next_upstream fastcgi_next_upstream, uwsgi_next_upstream, scgi_next_upstream, and memcached_next_upstream指令来处理这次错误的请求  fail_timeout:默认为10秒。某台Server达到max_fails次失败请求后，在fail_timeout期间内，nginx会认为这台Server暂时不可用，不会将请求分配给它  2.最少连接,把请求分配到连接数最少的server  upstream serverGroup {    least_conn;    server 192.168.0.100:8080;    server 192.168.0.101:8080;  }  3.ip_hash,根据访问客户端ip的hash值分配，这样同一客户端的请求都会被分配到同一个server上，如果牵扯到session的问题，用这个是最好的选择  upstream serverGroup {    ip_hash;    server 192.168.0.100:8080;    server 192.168.0.101:8080;  }}</code></pre><p>  在server节点下配置proxy_pass</p><pre><code>server {    listen  80;    server_name serverGroup;    location / {      proxy_pass   http://serverGroup; # 表示将所有请求转发到tomcats服务器组中配置的某一台服务器上    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下安装maven</title>
      <link href="/2018/05/13/Linux%E4%B8%8B%E5%AE%89%E8%A3%85maven/"/>
      <url>/2018/05/13/Linux%E4%B8%8B%E5%AE%89%E8%A3%85maven/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  Linux系统下离线安装maven</code></pre><p>1.在Apache官方网站下载对应系统的maven包然后解压maven</p><p>2.配置环境变量.(配置到当前用户的环境变量上)</p><p><code>sudo  vim ~/.bashrc #用vim打开当前用户的环境变量配置文件</code></p><p>在.bashrc文件底部加入以下内容,然后保存退出.(M2_HOME代表解压后的maven目录)</p><pre><code>export M2_HOME=/home/user/apache-maven-3.3.9export PATH=${M2_HOME}/bin:$PATH</code></pre><p>3.执行以下命令使刚刚的配置生效</p><pre><code>`source ~/.bashrc`</code></pre><p>4.验证安装结果,执行下列命令,如果一切无误,会正常出现对应的maven版本信息</p><pre><code>`mvn -v`</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux离线安装oracle JDK</title>
      <link href="/2018/05/13/JDK/"/>
      <url>/2018/05/13/JDK/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  本文是在deepin linux(基于debian发行版)系统环境下,debian,ubuntu以及其他debian衍生版同理适用</code></pre><p>如果电脑处于联网状态,那么可以使用apt包管理器在线安装,可使用以下命令在线安装:</p><p><code>sudo apt update #更新</code></p><p><code>sudo apt install oracle-java8 #安装</code></p><p> 下面重点介绍离线安装官网下载安装包的方式:</p><p> 1.oracle官网下载Linux对应的tar.gz安装包</p><p> 2.进入到存放安装包的目录下,执行以下命令将安装包的内容解压到在指定目录(/usr/local/java/文件夹自己事先建好)</p><p> <code>sudo tar zxvf ./xxxx.tar.gz  -C /usr/local/java</code></p><p>3.查看第二步是否成功,如果有/usr/local/java/下有jdk对应的目录结构,则表示成功</p><p><code>ls -anl /usr/local/java/</code></p><p>4.配置环境变量(此处配置到当前用户的环境变量上)</p><p><code>sudo  vim ~/.bashrc #用vim打开当前用户的环境变量配置文件</code></p><p>在.bashrc文件底部加入以下内容,然后保存退出</p><pre><code>export JAVA_HOME=/usr/local/java/java-8u5_xxxexport JRE_HOME=${JAVA_HOME}/jre   export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib   export PATH=${JAVA_HOME}/bin:$PATHunset _JAVA_OPTIONS</code></pre><p>5.执行以下命令使刚刚的配置生效</p><p><code>source ~/.bashrc</code></p><p>6.验证安装结果,执行下列命令,如果一切无误,会正常出现对应的java版本信息</p><p><code>java -version</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> java </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux增加使用文件代替swap分区分方法</title>
      <link href="/2018/05/13/Linux%E5%A2%9E%E5%8A%A0%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E4%BB%A3%E6%9B%BFswap%E5%88%86%E5%8C%BA%E5%88%86%E6%96%B9%E6%B3%95/"/>
      <url>/2018/05/13/Linux%E5%A2%9E%E5%8A%A0%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E4%BB%A3%E6%9B%BFswap%E5%88%86%E5%8C%BA%E5%88%86%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要:  在安装Linux系统的时候未对系统进行swap(交换分区),后续进入系统  可以采用新建文件的方式来代替swap分区.  以下所执行的系统环境是:deepin linux(基于debian发行版),  按理在Ubuntu,debian上也是可以的.</code></pre><p>注意:执行以下命令时,全部采用root账户的权限</p><p>1.创建要作为swap分区的文件:增加1GB大小的交换分区，则命令写法如下，其中的count等于想要的块的数量（bs*count=文件大小）</p><p><code>sudo dd if=/dev/zero of=/swapfile bs=1M count=1024</code></p><p>2.格式化为交换分区文件,建立swap的文件系统</p><p><code>sudo mkswap /swapfile</code></p><p>3.启用交换分区文件</p><p><code>sudo swapon /swapfile</code></p><p>4.使系统开机时自启用，在文件/etc/fstab中添加一行(可使用vim打开文件进行编辑)：</p><p><code>/swapfile swap swap defaults 0 0</code></p><p>5.验证结果,执行free 命令查看是否有交换分区</p><p><code>free -m</code></p><p>注:如果想移除swap分区文件,执行以下命令:</p><p><code>sudo swapoff /swapfile &amp;&amp; sudo rm /swapfile</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> swap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL字段值默认不区分大小写问题</title>
      <link href="/2018/05/13/MySQL%E5%AD%97%E6%AE%B5%E5%80%BC%E9%BB%98%E8%AE%A4%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/13/MySQL%E5%AD%97%E6%AE%B5%E5%80%BC%E9%BB%98%E8%AE%A4%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<pre><code>摘要：  mysql的字段值是默认不区分大小写的,但是用户在登录账户的时候严格区分大小写的,所以解决如下:</code></pre><p>1 .在不改变表任何结构的情况下,可以直接在查询条件后面的字段名或者字段值作为binary()函数的参数即可,如下:</p><p><code>select * from table_name t where binary(t.field) = &#39;Abc&#39;;</code></p><p>2 .在建表的时候在字段后面加上binary,或者用alter语句来改变字段类型,只需要加上binary</p><pre><code>`mysql&gt; create table t_user(-&gt; username varchar(20) binary-&gt; );`</code></pre><p>对已有的表进行alert</p><p><code>alter table table_name modify field varchar(20) binary</code></p><p>注:table_name换成具体对应的表名称.field换成具体对应的表的字段</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下离线安装nodejs</title>
      <link href="/2018/05/12/Linux%E4%B8%8B%E5%AE%89%E8%A3%85nodejs/"/>
      <url>/2018/05/12/Linux%E4%B8%8B%E5%AE%89%E8%A3%85nodejs/</url>
      
        <content type="html"><![CDATA[<h5 id="Linux下离线安装nodejs步骤"><a href="#Linux下离线安装nodejs步骤" class="headerlink" title="Linux下离线安装nodejs步骤:"></a>Linux下离线安装nodejs步骤:</h5><hr><p>1.在官网下载Linux版本的nodejs安装包,然后解压并且移动到/usr/local/目录,具体目录可随意指定</p><p><code>sudo tar -xvJf ./node-v8.9.3-linux-x64.tar.xz -C /usr/local/</code></p><p>2.配置环境变量，编辑～/.bashrc文件(当前用户的环境变量配置)</p><p><code>export NODE_HOME=/opt/node</code></p><p><code>export PATH=$PATH:$NODE_HOME/bin</code></p><p><code>export NODE_PATH=$NODE_HOME/lib/node_modules</code></p><p>3.使配置生效,执行source命令</p><p><code>source ~/.bashrc</code></p><p>4.执行如下命令校验配置是否生效</p><p><code>node -v</code></p><p><code>npm -v</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
